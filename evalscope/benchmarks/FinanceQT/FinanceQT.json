[
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Create an algorithm that uses the RiskParityPortfolioConstructionModel and trades the \"SPY\" and \"AAPL\" equities on a daily resolution.\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom Portfolio.RiskParityPortfolioConstructionModel import *\n\nclass RiakParityPortfolioAlgorithm(QCAlgorithm):\n    '''Example algorithm of using RiskParityPortfolioConstructionModel'''\n\n    def Initialize(self):\n        self.SetStartDate(2021, 2, 21)  # Set Start Date\n        self.SetEndDate(2021, 3, 30)\n        self.SetCash(100000)  # Set Strategy Cash\n        self.SetSecurityInitializer(lambda security: security.SetMarketPrice(self.GetLastKnownPrice(security)))\n        \n        self.AddEquity(\"SPY\", Resolution.Daily)\n        self.AddEquity(\"AAPL\", Resolution.Daily)\n\n        self.AddAlpha(ConstantAlphaModel(InsightType.Price, InsightDirection.Up, timedelta(1)))\n        self.SetPortfolioConstruction(RiskParityPortfolioConstructionModel())"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with the code to test that we receive the expected data when adding future option contracts individually using the \"AddFutureOptionContract\" method in the Lean Algorithmic Trading Engine?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### This regression algorithm tests that we receive the expected data when\n### we add future option contracts individually using <see cref=\"AddFutureOptionContract\"/>\n### </summary>\nclass AddFutureOptionContractDataStreamingRegressionAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        self.onDataReached = False\n        self.invested = False\n        self.symbolsReceived = []\n        self.expectedSymbolsReceived = []\n        self.dataReceived = {}\n\n        self.SetStartDate(2020, 1, 4)\n        self.SetEndDate(2020, 1, 8)\n\n        self.es20h20 = self.AddFutureContract(\n            Symbol.CreateFuture(Futures.Indices.SP500EMini, Market.CME, datetime(2020, 3, 20)),\n            Resolution.Minute).Symbol\n\n        self.es19m20 = self.AddFutureContract(\n            Symbol.CreateFuture(Futures.Indices.SP500EMini, Market.CME, datetime(2020, 6, 19)),\n            Resolution.Minute).Symbol\n\n        # Get option contract lists for 2020/01/05 (timedelta(days=1)) because Lean has local data for that date\n        optionChains = self.OptionChainProvider.GetOptionContractList(self.es20h20, self.Time + timedelta(days=1))\n        optionChains += self.OptionChainProvider.GetOptionContractList(self.es19m20, self.Time + timedelta(days=1))\n\n        for optionContract in optionChains:\n            self.expectedSymbolsReceived.append(self.AddFutureOptionContract(optionContract, Resolution.Minute).Symbol)\n\n    def OnData(self, data: Slice):\n        if not data.HasData:\n            return\n\n        self.onDataReached = True\n        hasOptionQuoteBars = False\n\n        for qb in data.QuoteBars.Values:\n            if qb.Symbol.SecurityType != SecurityType.FutureOption:\n                continue\n\n            hasOptionQuoteBars = True\n\n            self.symbolsReceived.append(qb.Symbol)\n            if qb.Symbol not in self.dataReceived:\n                self.dataReceived[qb.Symbol] = []\n\n            self.dataReceived[qb.Symbol].append(qb)\n\n        if self.invested or not hasOptionQuoteBars:\n            return\n\n        if data.ContainsKey(self.es20h20) and data.ContainsKey(self.es19m20):\n            self.SetHoldings(self.es20h20, 0.2)\n            self.SetHoldings(self.es19m20, 0.2)\n\n            self.invested = True\n\n    def OnEndOfAlgorithm(self):\n        self.symbolsReceived = list(set(self.symbolsReceived))\n        self.expectedSymbolsReceived = list(set(self.expectedSymbolsReceived))\n\n        if not self.onDataReached:\n            raise AssertionError(\"OnData() was never called.\")\n        if len(self.symbolsReceived) != len(self.expectedSymbolsReceived):\n            raise AssertionError(f\"Expected {len(self.expectedSymbolsReceived)} option contracts Symbols, found {len(self.symbolsReceived)}\")\n\n        missingSymbols = [expectedSymbol for expectedSymbol in self.expectedSymbolsReceived if expectedSymbol not in self.symbolsReceived]\n        if any(missingSymbols):\n            raise AssertionError(f'Symbols: \"{\", \".join(missingSymbols)}\" were not found in OnData')\n\n        for expectedSymbol in self.expectedSymbolsReceived:\n            data = self.dataReceived[expectedSymbol]\n            for dataPoint in data:\n                dataPoint.EndTime = datetime(1970, 1, 1)\n\n            nonDupeDataCount = len(set(data))\n            if nonDupeDataCount < 1000:\n                raise AssertionError(f\"Received too few data points. Expected >=1000, found {nonDupeDataCount} for {expectedSymbol}\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a query that would result in the following code being generated?\n\nCode:\n from AlgorithmImports import *\nfrom System.Collections.Generic import List\n\n### <summary>\n### In this algorithm we show how you can easily use the universe selection feature to fetch symbols\n### to be traded using the BaseData custom data system in combination with the AddUniverse{T} method.\n### AddUniverse{T} requires a function that will return the symbols to be traded.\n### </summary>\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"universes\" />\n### <meta name=\"tag\" content=\"custom universes\" />\nclass DropboxBaseDataUniverseSelectionAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n\n        self.UniverseSettings.Resolution = Resolution.Daily\n\n        # Order margin value has to have a minimum of 0.5% of Portfolio value, allows filtering out small trades and reduce fees.\n        # Commented so regression algorithm is more sensitive\n        #self.Settings.MinimumOrderMarginPortfolioPercentage = 0.005\n\n        self.SetStartDate(2017, 7, 4)\n        self.SetEndDate(2018, 7, 4)\n\n        self.AddUniverse(StockDataSource, \"my-stock-data-source\", self.stockDataSource)\n\n    def stockDataSource(self, data):\n        list = []\n        for item in data:\n            for symbol in item[\"Symbols\"]:\n                list.append(symbol)\n        return list\n\n    def OnData(self, slice):\n\n        if slice.Bars.Count == 0: return\n        if self._changes is None: return\n\n        # start fresh\n        self.Liquidate()\n\n        percentage = 1 / slice.Bars.Count\n        for tradeBar in slice.Bars.Values:\n            self.SetHoldings(tradeBar.Symbol, percentage)\n\n        # reset changes\n        self._changes = None\n\n    def OnSecuritiesChanged(self, changes):\n        self._changes = changes\n\nclass StockDataSource(PythonData):\n\n    def GetSource(self, config, date, isLiveMode):\n        url = \"https://www.dropbox.com/s/2l73mu97gcehmh7/daily-stock-picker-live.csv?dl=1\" if isLiveMode else \\\n            \"https://www.dropbox.com/s/ae1couew5ir3z9y/daily-stock-picker-backtest.csv?dl=1\"\n\n        return SubscriptionDataSource(url, SubscriptionTransportMedium.RemoteFile)\n\n    def Reader(self, config, line, date, isLiveMode):\n        if not (line.strip() and line[0].isdigit()): return None\n\n        stocks = StockDataSource()\n        stocks.Symbol = config.Symbol\n\n        csv = line.split(',')\n        if isLiveMode:\n            stocks.Time = date\n            stocks[\"Symbols\"] = csv\n        else:\n            stocks.Time = datetime.strptime(csv[0], \"%Y%m%d\")\n            stocks[\"Symbols\"] = csv[1:]\n        return stocks\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom System.Collections.Generic import List\n\n### <summary>\n### In this algorithm we show how you can easily use the universe selection feature to fetch symbols\n### to be traded using the BaseData custom data system in combination with the AddUniverse{T} method.\n### AddUniverse{T} requires a function that will return the symbols to be traded.\n### </summary>\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"universes\" />\n### <meta name=\"tag\" content=\"custom universes\" />\nclass DropboxBaseDataUniverseSelectionAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n\n        self.UniverseSettings.Resolution = Resolution.Daily\n\n        # Order margin value has to have a minimum of 0.5% of Portfolio value, allows filtering out small trades and reduce fees.\n        # Commented so regression algorithm is more sensitive\n        #self.Settings.MinimumOrderMarginPortfolioPercentage = 0.005\n\n        self.SetStartDate(2017, 7, 4)\n        self.SetEndDate(2018, 7, 4)\n\n        self.AddUniverse(StockDataSource, \"my-stock-data-source\", self.stockDataSource)\n\n    def stockDataSource(self, data):\n        list = []\n        for item in data:\n            for symbol in item[\"Symbols\"]:\n                list.append(symbol)\n        return list\n\n    def OnData(self, slice):\n\n        if slice.Bars.Count == 0: return\n        if self._changes is None: return\n\n        # start fresh\n        self.Liquidate()\n\n        percentage = 1 / slice.Bars.Count\n        for tradeBar in slice.Bars.Values:\n            self.SetHoldings(tradeBar.Symbol, percentage)\n\n        # reset changes\n        self._changes = None\n\n    def OnSecuritiesChanged(self, changes):\n        self._changes = changes\n\nclass StockDataSource(PythonData):\n\n    def GetSource(self, config, date, isLiveMode):\n        url = \"https://www.dropbox.com/s/2l73mu97gcehmh7/daily-stock-picker-live.csv?dl=1\" if isLiveMode else \\\n            \"https://www.dropbox.com/s/ae1couew5ir3z9y/daily-stock-picker-backtest.csv?dl=1\"\n\n        return SubscriptionDataSource(url, SubscriptionTransportMedium.RemoteFile)\n\n    def Reader(self, config, line, date, isLiveMode):\n        if not (line.strip() and line[0].isdigit()): return None\n\n        stocks = StockDataSource()\n        stocks.Symbol = config.Symbol\n\n        csv = line.split(',')\n        if isLiveMode:\n            stocks.Time = date\n            stocks[\"Symbols\"] = csv\n        else:\n            stocks.Time = datetime.strptime(csv[0], \"%Y%m%d\")\n            stocks[\"Symbols\"] = csv[1:]\n        return stocks"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Please provide me with the query that would result in the code provided.\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom OptionPriceModelForOptionStylesBaseRegressionAlgorithm import OptionPriceModelForOptionStylesBaseRegressionAlgorithm\n\n### <summary>\n### Regression algorithm exercising an equity covered American style option, using an option price model\n### that supports American style options and asserting that the option price model is used.\n### </summary>\nclass OptionPriceModelForSupportedAmericanOptionRegressionAlgorithm(OptionPriceModelForOptionStylesBaseRegressionAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2014, 6, 9)\n        self.SetEndDate(2014, 6, 9)\n\n        option = self.AddOption(\"AAPL\", Resolution.Minute)\n        # BaroneAdesiWhaley model supports American style options\n        option.PriceModel = OptionPriceModels.BaroneAdesiWhaley()\n\n        self.SetWarmup(2, Resolution.Daily)\n\n        self.Init(option, optionStyleIsSupported=True)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me an example of how to add options for a specific underlying equity security in a daily algorithm?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### This example demonstrates how to add options for a given underlying equity security.\n### It also shows how you can prefilter contracts easily based on strikes and expirations, and how you\n### can inspect the option chain to pick a specific option contract to trade.\n### </summary>\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"options\" />\n### <meta name=\"tag\" content=\"filter selection\" />\nclass BasicTemplateOptionsDailyAlgorithm(QCAlgorithm):\n    UnderlyingTicker = \"GOOG\"\n\n    def Initialize(self):\n        self.SetStartDate(2015, 12, 23)\n        self.SetEndDate(2016, 1, 20)\n        self.SetCash(100000)\n        self.optionExpired = False\n\n        equity = self.AddEquity(self.UnderlyingTicker, Resolution.Daily)\n        option = self.AddOption(self.UnderlyingTicker, Resolution.Daily)\n        self.option_symbol = option.Symbol\n\n        # set our strike/expiry filter for this option chain\n        option.SetFilter(lambda u: (u.CallsOnly().Strikes(0, 1).Expiration(0, 30)))\n\n        # use the underlying equity as the benchmark\n        self.SetBenchmark(equity.Symbol)\n\n    def OnData(self,slice):\n        if self.Portfolio.Invested: return\n\n        chain = slice.OptionChains.GetValue(self.option_symbol)\n        if chain is None:\n            return\n\n        # Grab us the contract nearest expiry\n        contracts = sorted(chain, key = lambda x: x.Expiry)\n\n        # if found, trade it\n        if len(contracts) == 0: return\n        symbol = contracts[0].Symbol\n        self.MarketOrder(symbol, 1)\n\n    def OnOrderEvent(self, orderEvent):\n        self.Log(str(orderEvent))\n\n        # Check for our expected OTM option expiry\n        if \"OTM\" in orderEvent.Message:\n\n            # Assert it is at midnight 1/16 (5AM UTC)\n            if orderEvent.UtcTime.month != 1 and orderEvent.UtcTime.day != 16 and orderEvent.UtcTime.hour != 5:\n                raise AssertionError(f\"Expiry event was not at the correct time, {orderEvent.UtcTime}\")\n\n            self.optionExpired = True\n\n    def OnEndOfAlgorithm(self):\n        # Assert we had our option expire and fill a liquidation order\n        if not self.optionExpired:\n            raise AssertionError(\"Algorithm did not process the option expiration like expected\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with an algorithm that illustrates how to get a security's industry-standard identifier from its `Symbol`?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Algorithm illustrating how to get a security's industry-standard identifier from its `Symbol`\n### </summary>\nclass IndustryStandardSecurityIdentifiersRegressionAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2014, 6, 5)\n        self.SetEndDate(2014, 6, 5)\n\n        equity = self.AddEquity(\"AAPL\").Symbol\n\n        cusip = equity.CUSIP\n        compositeFigi = equity.CompositeFIGI\n        sedol = equity.SEDOL\n        isin = equity.ISIN\n        cik = equity.CIK\n\n        self.CheckSymbolRepresentation(cusip, \"CUSIP\")\n        self.CheckSymbolRepresentation(compositeFigi, \"Composite FIGI\")\n        self.CheckSymbolRepresentation(sedol, \"SEDOL\")\n        self.CheckSymbolRepresentation(isin, \"ISIN\")\n        self.CheckSymbolRepresentation(f\"{cik}\", \"CIK\")\n\n        # Check Symbol API vs QCAlgorithm API\n        self.CheckAPIsSymbolRepresentations(cusip, self.CUSIP(equity), \"CUSIP\")\n        self.CheckAPIsSymbolRepresentations(compositeFigi, self.CompositeFIGI(equity), \"Composite FIGI\")\n        self.CheckAPIsSymbolRepresentations(sedol, self.SEDOL(equity), \"SEDOL\")\n        self.CheckAPIsSymbolRepresentations(isin, self.ISIN(equity), \"ISIN\")\n        self.CheckAPIsSymbolRepresentations(f\"{cik}\", f\"{self.CIK(equity)}\", \"CIK\")\n\n        self.Log(f\"\\nAAPL CUSIP: {cusip}\"\n                 f\"\\nAAPL Composite FIGI: {compositeFigi}\"\n                 f\"\\nAAPL SEDOL: {sedol}\"\n                 f\"\\nAAPL ISIN: {isin}\"\n                 f\"\\nAAPL CIK: {cik}\")\n\n    def CheckSymbolRepresentation(self, symbol: str, standard: str) -> None:\n        if not symbol:\n            raise Exception(f\"{standard} symbol representation is null or empty\")\n\n    def CheckAPIsSymbolRepresentations(self, symbolApiSymbol: str, algorithmApiSymbol: str, standard: str) -> None:\n        if symbolApiSymbol != algorithmApiSymbol:\n            raise Exception(f\"Symbol API {standard} symbol representation ({symbolApiSymbol}) does not match \"\n                            f\"QCAlgorithm API {standard} symbol representation ({algorithmApiSymbol})\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: What is the code for a regression algorithm testing portfolio construction model control over rebalancing, with specified date rules?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Regression algorithm testing portfolio construction model control over rebalancing,\n### specifying a date rules, see GH 4075.\n### </summary>\nclass PortfolioRebalanceOnDateRulesRegressionAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        ''' Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n\n        self.UniverseSettings.Resolution = Resolution.Daily\n\n        # Order margin value has to have a minimum of 0.5% of Portfolio value, allows filtering out small trades and reduce fees.\n        # Commented so regression algorithm is more sensitive\n        #self.Settings.MinimumOrderMarginPortfolioPercentage = 0.005\n\n        # let's use 0 minimum order margin percentage so we can assert trades are only submitted immediately after rebalance on Wednesday\n        # if not, due to TPV variations happening every day we might no cross the minimum on wednesday but yes another day of the week\n        self.Settings.MinimumOrderMarginPortfolioPercentage = 0\n\n        self.SetStartDate(2015,1,1)\n        self.SetEndDate(2017,1,1)\n\n        self.Settings.RebalancePortfolioOnInsightChanges = False\n        self.Settings.RebalancePortfolioOnSecurityChanges = False\n\n        self.SetUniverseSelection(CustomUniverseSelectionModel(\"CustomUniverseSelectionModel\", lambda time: [ \"AAPL\", \"IBM\", \"FB\", \"SPY\" ]))\n        self.SetAlpha(ConstantAlphaModel(InsightType.Price, InsightDirection.Up, TimeSpan.FromMinutes(20), 0.025, None))\n        self.SetPortfolioConstruction(EqualWeightingPortfolioConstructionModel(self.DateRules.Every(DayOfWeek.Wednesday)))\n        self.SetExecution(ImmediateExecutionModel())\n\n    def OnOrderEvent(self, orderEvent):\n        if orderEvent.Status == OrderStatus.Submitted:\n            self.Debug(str(orderEvent))\n            if self.UtcTime.weekday() != 2:\n                raise ValueError(str(self.UtcTime) + \" \" + str(orderEvent.Symbol) + \" \" + str(self.UtcTime.weekday()))"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a query that would result in the mentioned code?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### This regression algorithm tests that we only receive the option chain for a single future contract\n### in the option universe filter.\n### </summary>\nclass AddFutureOptionSingleOptionChainSelectedInUniverseFilterRegressionAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        self.invested = False\n        self.onDataReached = False\n        self.optionFilterRan = False\n        self.symbolsReceived = []\n        self.expectedSymbolsReceived = []\n        self.dataReceived = {}\n\n        self.SetStartDate(2020, 1, 4)\n        self.SetEndDate(2020, 1, 8)\n\n        self.es = self.AddFuture(Futures.Indices.SP500EMini, Resolution.Minute, Market.CME)\n        self.es.SetFilter(lambda futureFilter: futureFilter.Expiration(0, 365).ExpirationCycle([3, 6]))\n\n        self.AddFutureOption(self.es.Symbol, self.OptionContractUniverseFilterFunction)\n\n    def OptionContractUniverseFilterFunction(self, optionContracts: OptionFilterUniverse) -> OptionFilterUniverse:\n        self.optionFilterRan = True\n\n        expiry = list(set([x.Underlying.ID.Date for x in optionContracts]))\n        expiry = None if not any(expiry) else expiry[0]\n\n        symbol = [x.Underlying for x in optionContracts]\n        symbol = None if not any(symbol) else symbol[0]\n\n        if expiry is None or symbol is None:\n            raise AssertionError(\"Expected a single Option contract in the chain, found 0 contracts\")\n\n        enumerator = optionContracts.GetEnumerator()\n        while enumerator.MoveNext():\n            self.expectedSymbolsReceived.append(enumerator.Current)\n\n        return optionContracts\n\n    def OnData(self, data: Slice):\n        if not data.HasData:\n            return\n\n        self.onDataReached = True\n        hasOptionQuoteBars = False\n\n        for qb in data.QuoteBars.Values:\n            if qb.Symbol.SecurityType != SecurityType.FutureOption:\n                continue\n\n            hasOptionQuoteBars = True\n\n            self.symbolsReceived.append(qb.Symbol)\n            if qb.Symbol not in self.dataReceived:\n                self.dataReceived[qb.Symbol] = []\n\n            self.dataReceived[qb.Symbol].append(qb)\n\n        if self.invested or not hasOptionQuoteBars:\n            return\n\n        for chain in data.OptionChains.Values:\n            futureInvested = False\n            optionInvested = False\n\n            for option in chain.Contracts.Keys:\n                if futureInvested and optionInvested:\n                    return\n\n                future = option.Underlying\n\n                if not optionInvested and data.ContainsKey(option):\n                    self.MarketOrder(option, 1)\n                    self.invested = True\n                    optionInvested = True\n\n                if not futureInvested and data.ContainsKey(future):\n                    self.MarketOrder(future, 1)\n                    self.invested = True\n                    futureInvested = True\n\n    def OnEndOfAlgorithm(self):\n        super().OnEndOfAlgorithm()\n        self.symbolsReceived = list(set(self.symbolsReceived))\n        self.expectedSymbolsReceived = list(set(self.expectedSymbolsReceived))\n\n        if not self.optionFilterRan:\n            raise AssertionError(\"Option chain filter was never ran\")\n        if not self.onDataReached:\n            raise AssertionError(\"OnData() was never called.\")\n        if len(self.symbolsReceived) != len(self.expectedSymbolsReceived):\n            raise AssertionError(f\"Expected {len(self.expectedSymbolsReceived)} option contracts Symbols, found {len(self.symbolsReceived)}\")\n\n        missingSymbols = [expectedSymbol for expectedSymbol in self.expectedSymbolsReceived if expectedSymbol not in self.symbolsReceived]\n        if any(missingSymbols):\n            raise AssertionError(f'Symbols: \"{\", \".join(missingSymbols)}\" were not found in OnData')\n\n        for expectedSymbol in self.expectedSymbolsReceived:\n            data = self.dataReceived[expectedSymbol]\n            for dataPoint in data:\n                dataPoint.EndTime = datetime(1970, 1, 1)\n\n            nonDupeDataCount = len(set(data))\n            if nonDupeDataCount < 1000:\n                raise AssertionError(f\"Received too few data points. Expected >=1000, found {nonDupeDataCount} for {expectedSymbol}\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Please provide a query that would result in the code above.\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Tests the delisting of the composite Symbol (ETF symbol) and the removal of\n### the universe and the symbol from the algorithm, without adding a subscription via AddEquity\n### </summary>\nclass ETFConstituentUniverseCompositeDelistingRegressionAlgorithmNoAddEquityETF(QCAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2020, 12, 1)\n        self.SetEndDate(2021, 1, 31)\n        self.SetCash(100000)\n\n        self.universeSymbolCount = 0\n        self.universeAdded = False\n        self.universeRemoved = False\n\n        self.UniverseSettings.Resolution = Resolution.Hour\n        self.delistingDate = date(2021, 1, 21)\n\n        self.aapl = self.AddEquity(\"AAPL\", Resolution.Hour).Symbol\n        self.gdvd = Symbol.Create(\"GDVD\", SecurityType.Equity, Market.USA)\n\n        self.AddUniverse(self.Universe.ETF(self.gdvd, self.UniverseSettings, self.FilterETFs))\n\n    def FilterETFs(self, constituents):\n        if self.UtcTime.date() > self.delistingDate:\n            raise Exception(f\"Performing constituent universe selection on {self.UtcTime.strftime('%Y-%m-%d %H:%M:%S.%f')} after composite ETF has been delisted\")\n\n        constituentSymbols = [i.Symbol for i in constituents]\n        self.universeSymbolCount = len(constituentSymbols)\n\n        return constituentSymbols\n\n    def OnData(self, data):\n        if self.UtcTime.date() > self.delistingDate and any([i != self.aapl for i in data.Keys]):\n            raise Exception(\"Received unexpected slice in OnData(...) after universe was deselected\")\n\n        if not self.Portfolio.Invested:\n            self.SetHoldings(self.aapl, 0.5)\n\n    def OnSecuritiesChanged(self, changes):\n        if len(changes.AddedSecurities) != 0 and self.UtcTime.date() > self.delistingDate:\n            raise Exception(\"New securities added after ETF constituents were delisted\")\n\n        self.universeAdded = self.universeAdded or len(changes.AddedSecurities) >= self.universeSymbolCount\n        # Subtract 1 from universe Symbol count for AAPL, since it was manually added to the algorithm\n        self.universeRemoved = self.universeRemoved or (len(changes.RemovedSecurities) == self.universeSymbolCount - 1 and self.UtcTime.date() >= self.delistingDate and self.UtcTime.date() < self.EndDate.date())\n\n    def OnEndOfAlgorithm(self):\n        if not self.universeAdded:\n            raise Exception(\"ETF constituent universe was never added to the algorithm\")\n        if not self.universeRemoved:\n            raise Exception(\"ETF constituent universe was not removed from the algorithm after delisting\")\n        if len(self.ActiveSecurities) > 2:\n            raise Exception(f\"Expected less than 2 securities after algorithm ended, found {len(self.Securities)}\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a code template for a regression algorithm that exercises an equity covered European style option, using an option price model that supports European style options and asserts that the option price model is used?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom OptionPriceModelForOptionStylesBaseRegressionAlgorithm import OptionPriceModelForOptionStylesBaseRegressionAlgorithm\n\n### <summary>\n### Regression algorithm exercising an equity covered European style option, using an option price model\n### that supports European style options and asserting that the option price model is used.\n### </summary>\nclass OptionPriceModelForSupportedEuropeanOptionRegressionAlgorithm(OptionPriceModelForOptionStylesBaseRegressionAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2021, 1, 14)\n        self.SetEndDate(2021, 1, 14)\n\n        option = self.AddIndexOption(\"SPX\", Resolution.Hour)\n        # BlackScholes model supports European style options\n        option.PriceModel = OptionPriceModels.BlackScholes()\n\n        self.SetWarmup(7, Resolution.Daily)\n\n        self.Init(option, optionStyleIsSupported=True)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Please provide a possible query for a Quant Trader to a Coding assistant that would result in the code above.\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\nimport itertools\n\nfrom OptionStrategyFactoryMethodsBaseAlgorithm import *\n\n### <summary>\n### This algorithm demonstrate how to use OptionStrategies helper class to batch send orders for common strategies.\n### In this case, the algorithm tests the Call Calendar Spread and Short Call Calendar Spread strategies.\n### </summary>\nclass LongAndShortCallCalendarSpreadStrategiesAlgorithm(OptionStrategyFactoryMethodsBaseAlgorithm):\n\n    def ExpectedOrdersCount(self) -> int:\n        return 4\n\n    def TradeStrategy(self, chain: OptionChain, option_symbol: Symbol):\n        callContracts = sorted((contract for contract in chain if contract.Right == OptionRight.Call),\n                           key=lambda x: abs(x.Strike - chain.Underlying.Value))\n        for strike, group in itertools.groupby(callContracts, lambda x: x.Strike):\n            contracts = sorted(group, key=lambda x: x.Expiry)\n            if len(contracts) < 2: continue\n\n            self._near_expiration = contracts[0].Expiry\n            self._far_expiration = contracts[1].Expiry\n\n            self._call_calendar_spread = OptionStrategies.CallCalendarSpread(option_symbol, strike, self._near_expiration, self._far_expiration)\n            self._short_call_calendar_spread = OptionStrategies.ShortCallCalendarSpread(option_symbol, strike, self._near_expiration, self._far_expiration)\n            self.Buy(self._call_calendar_spread, 2)\n            return\n\n    def AssertStrategyPositionGroup(self, positionGroup: IPositionGroup, option_symbol: Symbol):\n        positions = list(positionGroup.Positions)\n        if len(positions) != 2:\n            raise Exception(f\"Expected position group to have 2 positions. Actual: {len(positions)}\")\n\n        nearExpirationPosition = next((position for position in positions\n                                       if position.Symbol.ID.OptionRight == OptionRight.Call and position.Symbol.ID.Date == self._near_expiration),\n                                      None)\n        if nearExpirationPosition is None or nearExpirationPosition.Quantity != -2:\n            raise Exception(f\"Expected near expiration position to be -2. Actual: {nearExpirationPosition.Quantity}\")\n\n        farExpirationPosition = next((position for position in positions\n                                      if position.Symbol.ID.OptionRight == OptionRight.Call and position.Symbol.ID.Date == self._far_expiration),\n                                     None)\n        if farExpirationPosition is None or farExpirationPosition.Quantity != 2:\n            raise Exception(f\"Expected far expiration position to be 2. Actual: {farExpirationPosition.Quantity}\")\n\n    def LiquidateStrategy(self):\n        # We should be able to close the position using the inverse strategy (a short call calendar spread)\n        self.Buy(self._short_call_calendar_spread, 2)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide an example of how to implement a Market On Close order for US Equities in the Lean Algorithmic Trading Engine using Python?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Demonstration of the Market On Close order for US Equities.\n### </summary>\n### <meta name=\"tag\" content=\"trading and orders\" />\n### <meta name=\"tag\" content=\"placing orders\" />\nclass MarketOnOpenOnCloseAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n\n        self.SetStartDate(2013,10,7)   #Set Start Date\n        self.SetEndDate(2013,10,11)    #Set End Date\n        self.SetCash(100000)           #Set Strategy Cash\n        # Find more symbols here: http://quantconnect.com/data\n        self.equity = self.AddEquity(\"SPY\", Resolution.Second, fillForward = True, extendedMarketHours = True)\n        self.__submittedMarketOnCloseToday = False\n        self.__last = datetime.min\n\n\n    def OnData(self, data):\n        '''OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.'''\n        if self.Time.date() != self.__last.date():   # each morning submit a market on open order\n            self.__submittedMarketOnCloseToday = False\n            self.MarketOnOpenOrder(\"SPY\", 100)\n            self.__last = self.Time\n\n        if not self.__submittedMarketOnCloseToday and self.equity.Exchange.ExchangeOpen:   # once the exchange opens submit a market on close order\n            self.__submittedMarketOnCloseToday = True\n            self.MarketOnCloseOrder(\"SPY\", -100)\n\n\n    def OnOrderEvent(self, fill):\n        order = self.Transactions.GetOrderById(fill.OrderId)\n        self.Log(\"{0} - {1}:: {2}\".format(self.Time, order.Type, fill))"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: What is the code to test market-on-close modeling with data from the post market?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\nclass MarketOnCloseOrderBufferExtendedMarketHoursRegressionAlgorithm(QCAlgorithm):\n    '''This regression test is a version of \"MarketOnCloseOrderBufferRegressionAlgorithm\"\n     where we test market-on-close modeling with data from the post market.'''\n    validOrderTicket = None\n    invalidOrderTicket = None\n    validOrderTicketExtendedMarketHours = None\n\n    def Initialize(self):\n        self.SetStartDate(2013,10,7)   #Set Start Date\n        self.SetEndDate(2013,10,8)    #Set End Date\n\n        self.AddEquity(\"SPY\", Resolution.Minute, extendedMarketHours = True)\n\n        def mocAtMidNight():\n            self.validOrderTicketAtMidnight = self.MarketOnCloseOrder(\"SPY\", 2)\n\n        self.Schedule.On(self.DateRules.Tomorrow, self.TimeRules.Midnight, mocAtMidNight)\n\n        # Modify our submission buffer time to 10 minutes\n        MarketOnCloseOrder.SubmissionTimeBuffer = timedelta(minutes=10)\n\n    def OnData(self, data):\n        # Test our ability to submit MarketOnCloseOrders\n        # Because we set our buffer to 10 minutes, any order placed\n        # before 3:50PM should be accepted, any after marked invalid\n\n        # Will not throw an order error and execute\n        if self.Time.hour == 15 and self.Time.minute == 49 and not self.validOrderTicket:\n            self.validOrderTicket = self.MarketOnCloseOrder(\"SPY\", 2)\n\n        # Will throw an order error and be marked invalid\n        if self.Time.hour == 15 and self.Time.minute == 51 and not self.invalidOrderTicket:\n            self.invalidOrderTicket = self.MarketOnCloseOrder(\"SPY\", 2)\n\n        # Will not throw an order error and execute\n        if self.Time.hour == 16 and self.Time.minute == 48 and not self.validOrderTicketExtendedMarketHours:\n            self.validOrderTicketExtendedMarketHours = self.MarketOnCloseOrder(\"SPY\", 2)\n\n    def OnEndOfAlgorithm(self):\n        # Set it back to default for other regressions\n        MarketOnCloseOrder.SubmissionTimeBuffer = MarketOnCloseOrder.DefaultSubmissionTimeBuffer\n\n        if self.validOrderTicket.Status != OrderStatus.Filled:\n            raise Exception(\"Valid order failed to fill\")\n\n        if self.invalidOrderTicket.Status != OrderStatus.Invalid:\n            raise Exception(\"Invalid order was not rejected\")\n\n        if self.validOrderTicketExtendedMarketHours.Status != OrderStatus.Filled:\n            raise Exception(\"Valid order during extended market hours failed to fill\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a code that demonstrates how to use the Option Chain Provider and manually select option contracts to trade?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Demonstration of the Option Chain Provider -- a much faster mechanism for manually specifying the option contracts you'd like to recieve\n### data for and manually subscribing to them.\n### </summary>\n### <meta name=\"tag\" content=\"strategy example\" />\n### <meta name=\"tag\" content=\"options\" />\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"selecting options\" />\n### <meta name=\"tag\" content=\"manual selection\" />\n\nclass OptionChainProviderAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n        self.SetStartDate(2015, 12, 24)\n        self.SetEndDate(2015, 12, 24)\n        self.SetCash(100000)\n        # add the underlying asset\n        self.equity = self.AddEquity(\"GOOG\", Resolution.Minute)\n        self.equity.SetDataNormalizationMode(DataNormalizationMode.Raw)\n        # initialize the option contract with empty string\n        self.contract = str()\n        self.contractsAdded = set()\n\n    def OnData(self, data):\n\n        if not self.Portfolio[self.equity.Symbol].Invested:\n            self.MarketOrder(self.equity.Symbol, 100)\n\n        if not (self.Securities.ContainsKey(self.contract) and self.Portfolio[self.contract].Invested):\n            self.contract = self.OptionsFilter(data)\n\n        if self.Securities.ContainsKey(self.contract) and not self.Portfolio[self.contract].Invested:\n            self.MarketOrder(self.contract, -1)\n\n    def OptionsFilter(self, data):\n        ''' OptionChainProvider gets a list of option contracts for an underlying symbol at requested date.\n            Then you can manually filter the contract list returned by GetOptionContractList.\n            The manual filtering will be limited to the information included in the Symbol\n            (strike, expiration, type, style) and/or prices from a History call '''\n\n        contracts = self.OptionChainProvider.GetOptionContractList(self.equity.Symbol, data.Time)\n        self.underlyingPrice = self.Securities[self.equity.Symbol].Price\n        # filter the out-of-money call options from the contract list which expire in 10 to 30 days from now on\n        otm_calls = [i for i in contracts if i.ID.OptionRight == OptionRight.Call and\n                                            i.ID.StrikePrice - self.underlyingPrice > 0 and\n                                            10 < (i.ID.Date - data.Time).days < 30]\n        if len(otm_calls) > 0:\n            contract = sorted(sorted(otm_calls, key = lambda x: x.ID.Date),\n                                                     key = lambda x: x.ID.StrikePrice - self.underlyingPrice)[0]\n            if contract not in self.contractsAdded:\n                self.contractsAdded.add(contract)\n                # use AddOptionContract() to subscribe the data for specified contract\n                self.AddOptionContract(contract, Resolution.Minute)\n            return contract\n        else:\n            return str()"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you help me write a regression test to check if a custom python indicator is keeping backwards compatibility with indicators that do not set the WarmUpPeriod or do not inherit from the PythonIndicator class?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom collections import deque\n\n### <summary>\n### Regression test to check python indicator is keeping backwards compatibility \n### with indicators that do not set WarmUpPeriod or do not inherit from PythonIndicator class.\n### </summary>\n### <meta name=\"tag\" content=\"indicators\" />\n### <meta name=\"tag\" content=\"indicator classes\" />\n### <meta name=\"tag\" content=\"custom indicator\" />\n### <meta name=\"tag\" content=\"regression test\" />\nclass CustomWarmUpPeriodIndicatorAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2013,10,7)\n        self.SetEndDate(2013,10,11)\n        self.AddEquity(\"SPY\", Resolution.Second)\n\n        # Create three python indicators\n        # - customNotWarmUp does not define WarmUpPeriod parameter\n        # - customWarmUp defines WarmUpPeriod parameter\n        # - customNotInherit defines WarmUpPeriod parameter but does not inherit from PythonIndicator class\n        # - csharpIndicator defines WarmUpPeriod parameter and represents the traditional LEAN C# indicator\n        self.customNotWarmUp = CSMANotWarmUp('customNotWarmUp', 60)\n        self.customWarmUp = CSMAWithWarmUp('customWarmUp', 60)\n        self.customNotInherit = CustomSMA('customNotInherit', 60)\n        self.csharpIndicator = SimpleMovingAverage('csharpIndicator', 60)\n\n        # Register the daily data of \"SPY\" to automatically update the indicators\n        self.RegisterIndicator(\"SPY\", self.customWarmUp, Resolution.Minute)\n        self.RegisterIndicator(\"SPY\", self.customNotWarmUp, Resolution.Minute)\n        self.RegisterIndicator(\"SPY\", self.customNotInherit, Resolution.Minute)\n        self.RegisterIndicator(\"SPY\", self.csharpIndicator, Resolution.Minute)\n\n        # Warm up customWarmUp indicator\n        self.WarmUpIndicator(\"SPY\", self.customWarmUp, Resolution.Minute)\n\n        # Check customWarmUp indicator has already been warmed up with the requested data\n        assert(self.customWarmUp.IsReady), \"customWarmUp indicator was expected to be ready\"\n        assert(self.customWarmUp.Samples == 60), \"customWarmUp indicator was expected to have processed 60 datapoints already\"\n\n        # Try to warm up customNotWarmUp indicator. It's expected from LEAN to skip the warm up process\n        # because this indicator doesn't define WarmUpPeriod parameter\n        self.WarmUpIndicator(\"SPY\", self.customNotWarmUp, Resolution.Minute)\n\n        # Check customNotWarmUp indicator is not ready and is using the default WarmUpPeriod value\n        assert(not self.customNotWarmUp.IsReady), \"customNotWarmUp indicator wasn't expected to be warmed up\"\n        assert(self.customNotWarmUp.WarmUpPeriod == 0), \"customNotWarmUp indicator WarmUpPeriod parameter was expected to be 0\"\n\n        # Warm up customNotInherit indicator. Though it does not inherit from PythonIndicator class,\n        # it defines WarmUpPeriod parameter so it's expected to be warmed up from LEAN\n        self.WarmUpIndicator(\"SPY\", self.customNotInherit, Resolution.Minute)\n\n        # Check customNotInherit indicator has already been warmed up with the requested data\n        assert(self.customNotInherit.IsReady), \"customNotInherit indicator was expected to be ready\"\n        assert(self.customNotInherit.Samples == 60), \"customNotInherit indicator was expected to have processed 60 datapoints already\"\n\n        # Warm up csharpIndicator\n        self.WarmUpIndicator(\"SPY\", self.csharpIndicator, Resolution.Minute)\n\n        # Check csharpIndicator indicator has already been warmed up with the requested data\n        assert(self.csharpIndicator.IsReady), \"csharpIndicator indicator was expected to be ready\"\n        assert(self.csharpIndicator.Samples == 60), \"csharpIndicator indicator was expected to have processed 60 datapoints already\"\n\n    def OnData(self, data):\n        if not self.Portfolio.Invested:\n            self.SetHoldings(\"SPY\", 1)\n\n        if self.Time.second == 0:\n            # Compute the difference between indicators values\n            diff = abs(self.customNotWarmUp.Current.Value - self.customWarmUp.Current.Value)\n            diff += abs(self.customNotInherit.Value - self.customNotWarmUp.Current.Value)\n            diff += abs(self.customNotInherit.Value - self.customWarmUp.Current.Value)\n            diff += abs(self.csharpIndicator.Current.Value - self.customWarmUp.Current.Value)\n            diff += abs(self.csharpIndicator.Current.Value - self.customNotWarmUp.Current.Value)\n            diff += abs(self.csharpIndicator.Current.Value - self.customNotInherit.Value)\n\n            # Check customNotWarmUp indicator is ready when the number of samples is bigger than its WarmUpPeriod parameter\n            assert(self.customNotWarmUp.IsReady == (self.customNotWarmUp.Samples >= 60)), \"customNotWarmUp indicator was expected to be ready when the number of samples were bigger that its WarmUpPeriod parameter\"\n\n            # Check their values are the same. We only need to check if customNotWarmUp indicator is ready because the other ones has already been asserted to be ready\n            assert(diff <= 1e-10 or (not self.customNotWarmUp.IsReady)), f\"The values of the indicators are not the same. Indicators difference is {diff}\"\n            \n# Python implementation of SimpleMovingAverage.\n# Represents the traditional simple moving average indicator (SMA) without Warm Up Period parameter defined\nclass CSMANotWarmUp(PythonIndicator):\n    def __init__(self, name, period):\n        super().__init__()\n        self.Name = name\n        self.Value = 0\n        self.queue = deque(maxlen=period)\n\n    # Update method is mandatory\n    def Update(self, input):\n        self.queue.appendleft(input.Value)\n        count = len(self.queue)\n        self.Value = np.sum(self.queue) / count\n        return count == self.queue.maxlen\n\n# Python implementation of SimpleMovingAverage.\n# Represents the traditional simple moving average indicator (SMA) With Warm Up Period parameter defined\nclass CSMAWithWarmUp(CSMANotWarmUp):\n    def __init__(self, name, period):\n        super().__init__(name, period)\n        self.WarmUpPeriod = period\n\n# Custom python implementation of SimpleMovingAverage.\n# Represents the traditional simple moving average indicator (SMA)\nclass CustomSMA():\n    def __init__(self, name, period):\n        self.Name = name\n        self.Value = 0\n        self.queue = deque(maxlen=period)\n        self.WarmUpPeriod = period\n        self.IsReady = False\n        self.Samples = 0\n\n    # Update method is mandatory\n    def Update(self, input):\n        self.Samples += 1\n        self.queue.appendleft(input.Value)\n        count = len(self.queue)\n        self.Value = np.sum(self.queue) / count\n        if count == self.queue.maxlen:\n            self.IsReady = True\n        return self.IsReady"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Write a query to initialize an algorithm using the Expiry Helper framework algorithm with the following settings:\n  - Set the data resolution to hourly\n  - Set the start date to October 7, 2013\n  - Set the end date to January 1, 2014\n  - Set the strategy cash to 100,000\n  - Use the manual universe selection model with the \"SPY\" stock\n  - Use the Expiry Helper Alpha Model\n  - Use the Equal Weighting Portfolio Construction Model\n  - Use the Immediate Execution Model\n  - Set the maximum drawdown per security to 0.01\n  - Log the insights generated in the OnInsightsGenerated event\n  - In the ExpiryHelperAlphaModel, update the insights based on the current weekday\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Expiry Helper algorithm uses Expiry helper class in an Alpha Model\n### </summary>\nclass ExpiryHelperAlphaModelFrameworkAlgorithm(QCAlgorithm):\n    '''Expiry Helper framework algorithm uses Expiry helper class in an Alpha Model'''\n\n    def Initialize(self):\n        ''' Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n\n        # Set requested data resolution\n        self.UniverseSettings.Resolution = Resolution.Hour\n\n        self.SetStartDate(2013,10,7)   #Set Start Date\n        self.SetEndDate(2014,1,1)      #Set End Date\n        self.SetCash(100000)           #Set Strategy Cash\n\n        symbols = [ Symbol.Create(\"SPY\", SecurityType.Equity, Market.USA) ]\n\n        # set algorithm framework models\n        self.SetUniverseSelection(ManualUniverseSelectionModel(symbols))\n        self.SetAlpha(self.ExpiryHelperAlphaModel())\n        self.SetPortfolioConstruction(EqualWeightingPortfolioConstructionModel())\n        self.SetExecution(ImmediateExecutionModel())\n        self.SetRiskManagement(MaximumDrawdownPercentPerSecurity(0.01))\n\n        self.InsightsGenerated += self.OnInsightsGenerated\n\n    def OnInsightsGenerated(self, s, e):\n        for insight in e.Insights:\n            self.Log(f\"{e.DateTimeUtc.isoweekday()}: Close Time {insight.CloseTimeUtc} {insight.CloseTimeUtc.isoweekday()}\")\n\n    class ExpiryHelperAlphaModel(AlphaModel):\n        nextUpdate = None\n        direction = InsightDirection.Up\n\n        def Update(self, algorithm, data):\n\n            if self.nextUpdate is not None and self.nextUpdate > algorithm.Time:\n                return []\n\n            expiry = Expiry.EndOfDay\n\n            # Use the Expiry helper to calculate a date/time in the future\n            self.nextUpdate = expiry(algorithm.Time)\n\n            weekday = algorithm.Time.isoweekday()\n\n            insights = []\n            for symbol in data.Bars.Keys:\n                # Expected CloseTime: next month on the same day and time\n                if weekday == 1:\n                    insights.append(Insight.Price(symbol, Expiry.OneMonth, self.direction))\n                # Expected CloseTime: next month on the 1st at market open time\n                elif weekday == 2:\n                    insights.append(Insight.Price(symbol, Expiry.EndOfMonth, self.direction))\n                # Expected CloseTime: next Monday at market open time\n                elif weekday == 3:\n                    insights.append(Insight.Price(symbol, Expiry.EndOfWeek, self.direction))\n                # Expected CloseTime: next day (Friday) at market open time\n                elif weekday == 4:\n                    insights.append(Insight.Price(symbol, Expiry.EndOfDay, self.direction))\n\n            return insights"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a code that demonstrates live trading functionality, including SMS, email, and webhook notifications?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom System.Globalization import *\n\n### <summary>\n### Live Trading Functionality Demonstration algorithm including SMS, Email and Web hook notifications.\n### </summary>\n### <meta name=\"tag\" content=\"live trading\" />\n### <meta name=\"tag\" content=\"alerts\" />\n### <meta name=\"tag\" content=\"sms alerts\" />\n### <meta name=\"tag\" content=\"web hooks\" />\n### <meta name=\"tag\" content=\"email alerts\" />\n### <meta name=\"tag\" content=\"runtime statistics\" />\n\nclass LiveTradingFeaturesAlgorithm(QCAlgorithm):\n\n    ### Initialize the Algorithm and Prepare Required Data\n    def Initialize(self):\n\n        self.SetStartDate(2013, 10, 7)\n        self.SetEndDate(2013, 10, 11)\n        self.SetCash(25000)\n\n        ##Equity Data for US Markets\n        self.AddSecurity(SecurityType.Equity, 'IBM', Resolution.Second)\n        \n        ##FOREX Data for Weekends: 24/6\n        self.AddSecurity(SecurityType.Forex, 'EURUSD', Resolution.Minute)\n\n        ##Custom/Bitcoin Live Data: 24/7\n        self.AddData(Bitcoin, 'BTC', Resolution.Second, TimeZones.Utc)\n        \n        ##if the algorithm is connected to the brokerage\n        self.is_connected = True\n\n\n    ### New Bitcoin Data Event\n    def OnData(Bitcoin, data):\n        if self.LiveMode:\n            self.SetRuntimeStatistic('BTC', str(data.Close))\n\n        if not self.Portfolio.HoldStock:\n            self.MarketOrder('BTC', 100)\n\n            ##Send a notification email/SMS/web request on events:\n            self.Notify.Email(\"myemail@gmail.com\", \"Test\", \"Test Body\", \"test attachment\")\n            self.Notify.Sms(\"+11233456789\", str(data.Time) + \">> Test message from live BTC server.\")\n            self.Notify.Web(\"http://api.quantconnect.com\", str(data.Time) + \">> Test data packet posted from live BTC server.\")\n\n\n    ### Raises the data event\n    def OnData(self, data):\n        if (not self.Portfolio['IBM'].HoldStock) and data.ContainsKey('IBM'):\n            quantity = int(np.floor(self.Portfolio.MarginRemaining / data['IBM'].Close))\n            self.MarketOrder('IBM',quantity)\n            self.Debug('Purchased IBM on ' + str(self.Time.strftime(\"%m/%d/%Y\")))\n            self.Notify.Email(\"myemail@gmail.com\", \"Test\", \"Test Body\", \"test attachment\")\n            \n    # Brokerage message event handler. This method is called for all types of brokerage messages.\n    def OnBrokerageMessage(self, messageEvent):\n        self.Debug(f\"Brokerage meesage received - {messageEvent.ToString()}\")\n\n    # Brokerage disconnected event handler. This method is called when the brokerage connection is lost.\n    def OnBrokerageDisconnect(self):\n        self.is_connected = False\n        self.Debug(f\"Brokerage disconnected!\")\n\n    # Brokerage reconnected event handler. This method is called when the brokerage connection is restored after a disconnection.\n    def OnBrokerageReconnect(self):\n        self.is_connected = True\n        self.Debug(f\"Brokerage reconnected!\")\n\n###Custom Data Type: Bitcoin data from Quandl - http://www.quandl.com/help/api-for-bitcoin-data\nclass Bitcoin(PythonData):\n\n    def GetSource(self, config, date, isLiveMode):\n        if isLiveMode:\n            return SubscriptionDataSource(\"https://www.bitstamp.net/api/ticker/\", SubscriptionTransportMedium.Rest)\n        \n        return  SubscriptionDataSource(\"https://www.quandl.com/api/v3/datasets/BCHARTS/BITSTAMPUSD.csv?order=asc\", SubscriptionTransportMedium.RemoteFile)\n\n\n    def Reader(self, config, line, date, isLiveMode):\n        coin = Bitcoin()\n        coin.Symbol = config.Symbol\n\n        if isLiveMode:\n            # Example Line Format:\n            # {\"high\": \"441.00\", \"last\": \"421.86\", \"timestamp\": \"1411606877\", \"bid\": \"421.96\", \"vwap\": \"428.58\", \"volume\": \"14120.40683975\", \"low\": \"418.83\", \"ask\": \"421.99\"}\n            try:\n                liveBTC = json.loads(line)\n\n                # If value is zero, return None\n                value = liveBTC[\"last\"]\n                if value == 0: return None\n\n                coin.Time = datetime.now()\n                coin.Value = value\n                coin[\"Open\"] = float(liveBTC[\"open\"])\n                coin[\"High\"] = float(liveBTC[\"high\"])\n                coin[\"Low\"] = float(liveBTC[\"low\"])\n                coin[\"Close\"] = float(liveBTC[\"last\"])\n                coin[\"Ask\"] = float(liveBTC[\"ask\"])\n                coin[\"Bid\"] = float(liveBTC[\"bid\"])\n                coin[\"VolumeBTC\"] = float(liveBTC[\"volume\"])\n                coin[\"WeightedPrice\"] = float(liveBTC[\"vwap\"])\n                return coin\n            except ValueError:\n                # Do nothing, possible error in json decoding\n                return None\n\n        # Example Line Format:\n        # Date      Open   High    Low     Close   Volume (BTC)    Volume (Currency)   Weighted Price\n        # 2011-09-13 5.8    6.0     5.65    5.97    58.37138238,    346.0973893944      5.929230648356\n        if not (line.strip() and line[0].isdigit()): return None\n\n        try:\n            data = line.split(',')\n            coin.Time = datetime.strptime(data[0], \"%Y-%m-%d\")\n            coin.Value = float(data[4])\n            coin[\"Open\"] = float(data[1])\n            coin[\"High\"] = float(data[2])\n            coin[\"Low\"] = float(data[3])\n            coin[\"Close\"] = float(data[4])\n            coin[\"VolumeBTC\"] = float(data[5])\n            coin[\"VolumeUSD\"] = float(data[6])\n            coin[\"WeightedPrice\"] = float(data[7])\n            return coin\n\n        except ValueError:\n            # Do nothing, possible error in json decoding\n            return None"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you please provide me with an example of how to request historical data for multiple FOREX contracts using different resolutions in the QuantConnect platform?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Algorithm demonstrating FOREX asset types and requesting history on them in bulk. As FOREX uses\n### QuoteBars you should request slices\n### </summary>\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"history and warm up\" />\n### <meta name=\"tag\" content=\"history\" />\n### <meta name=\"tag\" content=\"forex\" />\nclass BasicTemplateForexAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n        # Set the cash we'd like to use for our backtest\n        self.SetCash(100000)\n\n        # Start and end dates for the backtest.\n        self.SetStartDate(2013, 10, 7)\n        self.SetEndDate(2013, 10, 11)\n\n        # Add FOREX contract you want to trade\n        # find available contracts here https://www.quantconnect.com/data#forex/oanda/cfd\n        self.AddForex(\"EURUSD\", Resolution.Minute)\n        self.AddForex(\"GBPUSD\", Resolution.Minute)\n        self.AddForex(\"EURGBP\", Resolution.Minute)\n\n        self.History(5, Resolution.Daily)\n        self.History(5, Resolution.Hour)\n        self.History(5, Resolution.Minute)\n\n        history = self.History(TimeSpan.FromSeconds(5), Resolution.Second)\n\n        for data in sorted(history, key=lambda x: x.Time):\n            for key in data.Keys:\n                self.Log(str(key.Value) + \": \" + str(data.Time) + \" > \" + str(data[key].Value))\n\n    def OnData(self, data):\n        # Print to console to verify that data is coming in\n        for key in data.Keys:\n            self.Log(str(key.Value) + \": \" + str(data.Time) + \" > \" + str(data[key].Value))"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you help me write a code that asserts that consolidated bars are of type `QuoteBar` when `QCAlgorithm.Consolidate()` is called with `tickType=TickType.Quote`?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Algorithm asserting that consolidated bars are of type `QuoteBar` when `QCAlgorithm.Consolidate()` is called with `tickType=TickType.Quote`\n### </summary>\nclass CorrectConsolidatedBarTypeForTickTypesAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2013, 10, 7)\n        self.SetEndDate(2013, 10, 7)\n\n        symbol = self.AddEquity(\"SPY\", Resolution.Tick).Symbol\n\n        self.Consolidate(symbol, timedelta(minutes=1), TickType.Quote, self.quote_tick_consolidation_handler)\n        self.Consolidate(symbol, timedelta(minutes=1), TickType.Trade, self.trade_tick_consolidation_handler)\n\n        self.quote_tick_consolidation_handler_called = False\n        self.trade_tick_consolidation_handler_called = False\n\n    def OnData(self, slice: Slice) -> None:\n        if self.Time.hour > 9:\n            self.Quit(\"Early quit to save time\")\n\n    def OnEndOfAlgorithm(self):\n        if not self.quote_tick_consolidation_handler_called:\n            raise Exception(\"quote_tick_consolidation_handler was not called\")\n\n        if not self.trade_tick_consolidation_handler_called:\n            raise Exception(\"trade_tick_consolidation_handler was not called\")\n\n    def quote_tick_consolidation_handler(self, consolidated_bar: QuoteBar) -> None:\n        if type(consolidated_bar) != QuoteBar:\n            raise Exception(f\"Expected the consolidated bar to be of type {QuoteBar} but was {type(consolidated_bar)}\")\n\n        self.quote_tick_consolidation_handler_called = True\n\n    def trade_tick_consolidation_handler(self, consolidated_bar: TradeBar) -> None:\n        if type(consolidated_bar) != TradeBar:\n            raise Exception(f\"Expected the consolidated bar to be of type {TradeBar} but was {type(consolidated_bar)}\")\n\n        self.trade_tick_consolidation_handler_called = True"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I access futures history for a given root symbol with extended market hours?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\nfrom BasicTemplateFuturesHistoryAlgorithm import BasicTemplateFuturesHistoryAlgorithm\n\n### <summary>\n### This example demonstrates how to get access to futures history for a given root symbol with extended market hours.\n### It also shows how you can prefilter contracts easily based on expirations, and inspect the futures\n### chain to pick a specific contract to trade.\n### </summary>\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"history and warm up\" />\n### <meta name=\"tag\" content=\"history\" />\n### <meta name=\"tag\" content=\"futures\" />\nclass BasicTemplateFuturesHistoryWithExtendedMarketHoursAlgorithm(BasicTemplateFuturesHistoryAlgorithm):\n\n    def GetExtendedMarketHours(self):\n        return True\n\n    def GetExpectedHistoryCallCount(self):\n        return 49"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a code that tests Out of The Money (OTM) index option expiry for calls?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": "# QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.\n# Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License\n\nfrom AlgorithmImports import *\n\n### <summary>\n### This regression algorithm tests Out of The Money (OTM) index option expiry for calls.\n### We expect 2 orders from the algorithm, which are:\n###\n###   * Initial entry, buy SPX Call Option (expiring OTM)\n###     - contract expires worthless, not exercised, so never opened a position in the underlying\n###\n###   * Liquidation of worthless SPX call option (expiring OTM)\n###\n### Additionally, we test delistings for index options and assert that our\n### portfolio holdings reflect the orders the algorithm has submitted.\n### </summary>\n### <remarks>\n### Total Trades in regression algorithm should be 1, but expiration is counted as a trade.\n### See related issue: https://github.com/QuantConnect/Lean/issues/4854\n### </remarks>\nclass IndexOptionCallOTMExpiryRegressionAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2021, 1, 4)\n        self.SetEndDate(2021, 1, 31)\n\n        self.spx = self.AddIndex(\"SPX\", Resolution.Minute).Symbol\n\n        # Select a index option call expiring OTM, and adds it to the algorithm.\n        self.spxOption = list(self.OptionChainProvider.GetOptionContractList(self.spx, self.Time))\n        self.spxOption = [i for i in self.spxOption if i.ID.StrikePrice <= 3200 and i.ID.OptionRight == OptionRight.Put and i.ID.Date.year == 2021 and i.ID.Date.month == 1]\n        self.spxOption = list(sorted(self.spxOption, key=lambda x: x.ID.StrikePrice, reverse=True))[0]\n        self.spxOption = self.AddIndexOptionContract(self.spxOption, Resolution.Minute).Symbol\n\n        self.expectedContract = Symbol.CreateOption(\n            self.spx, \n            Market.USA, \n            OptionStyle.European, \n            OptionRight.Put, \n            3200, \n            datetime(2021, 1, 15)\n        )\n\n        if self.spxOption != self.expectedContract:\n            raise Exception(f\"Contract {self.expectedContract} was not found in the chain\")\n\n        self.Schedule.On(\n            self.DateRules.Tomorrow, \n            self.TimeRules.AfterMarketOpen(self.spx, 1), \n            lambda: self.MarketOrder(self.spxOption, 1)\n        )\n\n    def OnData(self, data: Slice):\n        # Assert delistings, so that we can make sure that we receive the delisting warnings at\n        # the expected time. These assertions detect bug #4872\n        for delisting in data.Delistings.Values:\n            if delisting.Type == DelistingType.Warning:\n                if delisting.Time != datetime(2021, 1, 15):\n                    raise Exception(f\"Delisting warning issued at unexpected date: {delisting.Time}\")\n\n            if delisting.Type == DelistingType.Delisted:\n                if delisting.Time != datetime(2021, 1, 16):\n                    raise Exception(f\"Delisting happened at unexpected date: {delisting.Time}\")\n\n    def OnOrderEvent(self, orderEvent: OrderEvent):\n        if orderEvent.Status != OrderStatus.Filled:\n            # There's lots of noise with OnOrderEvent, but we're only interested in fills.\n            return\n\n        if orderEvent.Symbol not in self.Securities:\n            raise Exception(f\"Order event Symbol not found in Securities collection: {orderEvent.Symbol}\")\n\n        security = self.Securities[orderEvent.Symbol]\n        if security.Symbol == self.spx:\n            raise Exception(\"Invalid state: did not expect a position for the underlying to be opened, since this contract expires OTM\")\n\n        if security.Symbol == self.expectedContract:\n            self.AssertIndexOptionContractOrder(orderEvent, security)\n        else:\n            raise Exception(f\"Received order event for unknown Symbol: {orderEvent.Symbol}\")\n\n    def AssertIndexOptionContractOrder(self, orderEvent: OrderEvent, option: Security):\n        if orderEvent.Direction == OrderDirection.Buy and option.Holdings.Quantity != 1:\n            raise Exception(f\"No holdings were created for option contract {option.Symbol}\")\n        if orderEvent.Direction == OrderDirection.Sell and option.Holdings.Quantity != 0:\n            raise Exception(\"Holdings were found after a filled option exercise\")\n        if orderEvent.Direction == OrderDirection.Sell and not \"OTM\" in orderEvent.Message:\n            raise Exception(\"Contract did not expire OTM\")\n        if \"Exercise\" in orderEvent.Message:\n            raise Exception(\"Exercised option, even though it expires OTM\")\n\n    ### <summary>\n    ### Ran at the end of the algorithm to ensure the algorithm has no holdings\n    ### </summary>\n    ### <exception cref=\"Exception\">The algorithm has holdings</exception>\n    def OnEndOfAlgorithm(self):\n        if self.Portfolio.Invested:\n            raise Exception(f\"Expected no holdings at end of algorithm, but are invested in: {', '.join(self.Portfolio.Keys)}\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I convert an old algorithm into the framework in Lean Algorithmic Trading Engine?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Demonstration algorithm showing how to easily convert an old algorithm into the framework.\n###\n###  1. When making orders, also create insights for the correct direction (up/down/flat), can also set insight prediction period/magnitude/direction\n###  2. Emit insights before placing any trades\n###  3. Profit :)\n###  </summary>\n###  <meta name=\"tag\" content=\"indicators\" />\n###  <meta name=\"tag\" content=\"indicator classes\" />\n###  <meta name=\"tag\" content=\"plotting indicators\" />\nclass ConvertToFrameworkAlgorithm(QCAlgorithm):\n    '''Demonstration algorithm showing how to easily convert an old algorithm into the framework.'''\n\n    FastEmaPeriod = 12\n    SlowEmaPeriod = 26\n\n    def Initialize(self):\n        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n\n        self.SetStartDate(2004, 1, 1)\n        self.SetEndDate(2015, 1, 1)\n\n        self.symbol = self.AddSecurity(SecurityType.Equity, 'SPY', Resolution.Daily).Symbol\n\n        # define our daily macd(12,26) with a 9 day signal\n        self.macd = self.MACD(self.symbol, self.FastEmaPeriod, self.SlowEmaPeriod, 9, MovingAverageType.Exponential, Resolution.Daily)\n\n\n    def OnData(self, data):\n        '''OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\n        Args:\n            data: Slice object with your stock data'''\n        # wait for our indicator to be ready\n        if not self.macd.IsReady or not data.ContainsKey(self.symbol) or data[self.symbol] is None: return\n\n        holding = self.Portfolio[self.symbol]\n\n        signalDeltaPercent = float(self.macd.Current.Value - self.macd.Signal.Current.Value) / float(self.macd.Fast.Current.Value)\n        tolerance = 0.0025\n\n        # if our macd is greater than our signal, then let's go long\n        if holding.Quantity <= 0 and signalDeltaPercent > tolerance:\n            # 1. Call EmitInsights with insights created in correct direction, here we're going long\n            #    The EmitInsights method can accept multiple insights separated by commas\n            self.EmitInsights(\n                # Creates an insight for our symbol, predicting that it will move up within the fast ema period number of days\n                Insight.Price(self.symbol, timedelta(self.FastEmaPeriod), InsightDirection.Up)\n            )\n\n            # longterm says buy as well\n            self.SetHoldings(self.symbol, 1)\n\n        # if our macd is less than our signal, then let's go short\n        elif holding.Quantity >= 0 and signalDeltaPercent < -tolerance:\n            # 1. Call EmitInsights with insights created in correct direction, here we're going short\n            #    The EmitInsights method can accept multiple insights separated by commas\n            self.EmitInsights(\n                # Creates an insight for our symbol, predicting that it will move down within the fast ema period number of days\n                Insight.Price(self.symbol, timedelta(self.FastEmaPeriod), InsightDirection.Down)\n            )\n\n            self.SetHoldings(self.symbol, -1)\n\n        # if we wanted to liquidate our positions\n        ## 1. Call EmitInsights with insights create in the correct direction -- Flat\n        \n        #self.EmitInsights(\n            # Creates an insight for our symbol, predicting that it will move down or up within the fast ema period number of days, depending on our current position\n            # Insight.Price(self.symbol, timedelta(self.FastEmaPeriod), InsightDirection.Flat)\n        #)\n        \n        # self.Liquidate()\n\n        # plot both lines\n        self.Plot(\"MACD\", self.macd, self.macd.Signal)\n        self.Plot(self.symbol.Value, self.macd.Fast, self.macd.Slow)\n        self.Plot(self.symbol.Value, \"Open\", data[self.symbol].Open)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Please provide me with a basic template algorithm that trades futures and includes extended market hours.\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\nfrom BasicTemplateFuturesFrameworkAlgorithm import BasicTemplateFuturesFrameworkAlgorithm\n\n### <summary>\n### Basic template futures framework algorithm uses framework components\n### to define an algorithm that trades futures.\n### </summary>\nclass BasicTemplateFuturesFrameworkWithExtendedMarketAlgorithm(BasicTemplateFuturesFrameworkAlgorithm):\n\n    def GetExtendedMarketHours(self):\n        return True"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide a code example for adding custom data to a QuantConnect algorithm and performing coarse selection using a custom universe selection model?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom QuantConnect.Data.Custom.IconicTypes import *\n\nclass CustomDataLinkedIconicTypeAddDataCoarseSelectionRegressionAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n        self.SetStartDate(2014, 3, 24)\n        self.SetEndDate(2014, 4, 7)\n        self.SetCash(100000)\n\n        self.UniverseSettings.Resolution = Resolution.Daily\n\n        self.AddUniverseSelection(CoarseFundamentalUniverseSelectionModel(self.CoarseSelector))\n\n    def CoarseSelector(self, coarse):\n        symbols = [\n            Symbol.Create(\"AAPL\", SecurityType.Equity, Market.USA),\n            Symbol.Create(\"BAC\", SecurityType.Equity, Market.USA),\n            Symbol.Create(\"FB\", SecurityType.Equity, Market.USA),\n            Symbol.Create(\"GOOGL\", SecurityType.Equity, Market.USA),\n            Symbol.Create(\"GOOG\", SecurityType.Equity, Market.USA),\n            Symbol.Create(\"IBM\", SecurityType.Equity, Market.USA),\n        ]\n\n        self.customSymbols = []\n\n        for symbol in symbols:\n            self.customSymbols.append(self.AddData(LinkedData, symbol, Resolution.Daily).Symbol)\n\n        return symbols\n\n    def OnData(self, data):\n        if not self.Portfolio.Invested and len(self.Transactions.GetOpenOrders()) == 0:\n            aapl = Symbol.Create(\"AAPL\", SecurityType.Equity, Market.USA)\n            self.SetHoldings(aapl, 0.5)\n\n        for customSymbol in self.customSymbols:\n            if not self.ActiveSecurities.ContainsKey(customSymbol.Underlying):\n                raise Exception(f\"Custom data undelrying ({customSymbol.Underlying}) Symbol was not found in active securities\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you please provide me with a query that would result in the code above?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from cmath import isclose\nfrom AlgorithmImports import *\n\n### <summary>\n### Algorithm demonstrating and ensuring that Bybit crypto futures brokerage model works as expected\n### </summary>\nclass BybitCryptoFuturesRegressionAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n\n        self.SetStartDate(2022, 12, 13)\n        self.SetEndDate(2022, 12, 13)\n\n        # Set strategy cash (USD)\n        self.SetCash(100000)\n\n        self.SetBrokerageModel(BrokerageName.Bybit, AccountType.Margin)\n\n        # Translate lines 44-59 to Python:\n\n        self.AddCrypto(\"BTCUSDT\", Resolution.Minute)\n\n        self.btcUsdt = self.AddCryptoFuture(\"BTCUSDT\", Resolution.Minute)\n        self.btcUsd = self.AddCryptoFuture(\"BTCUSD\", Resolution.Minute)\n\n        # create two moving averages\n        self.fast = self.EMA(self.btcUsdt.Symbol, 30, Resolution.Minute)\n        self.slow = self.EMA(self.btcUsdt.Symbol, 60, Resolution.Minute)\n\n        self.interestPerSymbol = {}\n        self.interestPerSymbol[self.btcUsd.Symbol] = 0\n        self.interestPerSymbol[self.btcUsdt.Symbol] = 0\n\n        # the amount of USDT we need to hold to trade 'BTCUSDT'\n        self.btcUsdt.QuoteCurrency.SetAmount(200)\n        # the amount of BTC we need to hold to trade 'BTCUSD'\n        self.btcUsd.BaseCurrency.SetAmount(0.005)\n\n    def OnData(self, data):\n        interestRates = data.Get[MarginInterestRate]()\n        for interestRate in interestRates:\n            self.interestPerSymbol[interestRate.Key] += 1\n\n            cachedInterestRate = self.Securities[interestRate.Key].Cache.GetData[MarginInterestRate]()\n            if cachedInterestRate != interestRate.Value:\n                raise Exception(f\"Unexpected cached margin interest rate for {interestRate.Key}!\")\n\n        if not self.slow.IsReady:\n            return\n\n        if self.fast > self.slow:\n            if not self.Portfolio.Invested and self.Transactions.OrdersCount == 0:\n                ticket = self.Buy(self.btcUsd.Symbol, 1000)\n                if ticket.Status != OrderStatus.Invalid:\n                    raise Exception(f\"Unexpected valid order {ticket}, should fail due to margin not sufficient\")\n\n                self.Buy(self.btcUsd.Symbol, 100)\n\n                marginUsed = self.Portfolio.TotalMarginUsed\n                btcUsdHoldings = self.btcUsd.Holdings\n\n                # Coin futures value is 100 USD\n                holdingsValueBtcUsd = 100\n                if abs(btcUsdHoldings.TotalSaleVolume - holdingsValueBtcUsd) > 1:\n                    raise Exception(f\"Unexpected TotalSaleVolume {btcUsdHoldings.TotalSaleVolume}\")\n                if abs(btcUsdHoldings.AbsoluteHoldingsCost - holdingsValueBtcUsd) > 1:\n                    raise Exception(f\"Unexpected holdings cost {btcUsdHoldings.HoldingsCost}\")\n                # margin used is based on the maintenance rate\n                if (abs(btcUsdHoldings.AbsoluteHoldingsCost * 0.05 - marginUsed) > 1 or\n                    not isclose(self.btcUsd.BuyingPowerModel.GetMaintenanceMargin(MaintenanceMarginParameters.ForCurrentHoldings(self.btcUsd)).Value, marginUsed)):\n                    raise Exception(f\"Unexpected margin used {marginUsed}\")\n\n                self.Buy(self.btcUsdt.Symbol, 0.01)\n\n                marginUsed = self.Portfolio.TotalMarginUsed - marginUsed\n                btcUsdtHoldings = self.btcUsdt.Holdings\n\n                # USDT futures value is based on it's price\n                holdingsValueUsdt = self.btcUsdt.Price * self.btcUsdt.SymbolProperties.ContractMultiplier * 0.01\n\n                if abs(btcUsdtHoldings.TotalSaleVolume - holdingsValueUsdt) > 1:\n                    raise Exception(f\"Unexpected TotalSaleVolume {btcUsdtHoldings.TotalSaleVolume}\")\n                if abs(btcUsdtHoldings.AbsoluteHoldingsCost - holdingsValueUsdt) > 1:\n                    raise Exception(f\"Unexpected holdings cost {btcUsdtHoldings.HoldingsCost}\")\n                if (abs(btcUsdtHoldings.AbsoluteHoldingsCost * 0.05 - marginUsed) > 1 or\n                    not isclose(self.btcUsdt.BuyingPowerModel.GetMaintenanceMargin(MaintenanceMarginParameters.ForCurrentHoldings(self.btcUsdt)).Value, marginUsed)):\n                    raise Exception(f\"Unexpected margin used {marginUsed}\")\n\n                 # position just opened should be just spread here\n                unrealizedProfit = self.Portfolio.TotalUnrealizedProfit\n                if (5 - abs(unrealizedProfit)) < 0:\n                    raise Exception(f\"Unexpected TotalUnrealizedProfit {self.Portfolio.TotalUnrealizedProfit}\")\n\n                if self.Portfolio.TotalProfit != 0:\n                    raise Exception(f\"Unexpected TotalProfit {self.Portfolio.TotalProfit}\")\n        # let's revert our position\n        elif self.Transactions.OrdersCount == 3:\n            self.Sell(self.btcUsd.Symbol, 300)\n\n            btcUsdHoldings = self.btcUsd.Holdings\n            if abs(btcUsdHoldings.AbsoluteHoldingsCost - 100 * 2) > 1:\n                raise Exception(f\"Unexpected holdings cost {btcUsdHoldings.HoldingsCost}\")\n\n            self.Sell(self.btcUsdt.Symbol, 0.03)\n\n            # USDT futures value is based on it's price\n            holdingsValueUsdt = self.btcUsdt.Price * self.btcUsdt.SymbolProperties.ContractMultiplier * 0.02\n            if abs(self.btcUsdt.Holdings.AbsoluteHoldingsCost - holdingsValueUsdt) > 1:\n                raise Exception(f\"Unexpected holdings cost {self.btcUsdt.Holdings.HoldingsCost}\")\n\n            # position just opened should be just spread here\n            profit = self.Portfolio.TotalUnrealizedProfit\n            if (5 - abs(profit)) < 0:\n                raise Exception(f\"Unexpected TotalUnrealizedProfit {self.Portfolio.TotalUnrealizedProfit}\")\n            # we barely did any difference on the previous trade\n            if (5 - abs(self.Portfolio.TotalProfit)) < 0:\n                raise Exception(f\"Unexpected TotalProfit {self.Portfolio.TotalProfit}\")\n\n    def OnOrderEvent(self, orderEvent):\n        self.Debug(\"{} {}\".format(self.Time, orderEvent.ToString()))\n\n    def OnEndOfAlgorithm(self):\n        self.Log(f\"{self.Time} - TotalPortfolioValue: {self.Portfolio.TotalPortfolioValue}\")\n        self.Log(f\"{self.Time} - CashBook: {self.Portfolio.CashBook}\")\n\n        if any(x == 0 for x in self.interestPerSymbol.values()):\n            raise Exception(\"Expected interest rate data for all symbols\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I disable the sufficient margin call verification in my algorithm?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Shows how setting to use the SecurityMarginModel.Null (or BuyingPowerModel.Null)\n### to disable the sufficient margin call verification.\n### See also: <see cref=\"OptionEquityBullCallSpreadRegressionAlgorithm\"/>\n### </summary>\n### <meta name=\"tag\" content=\"reality model\" />\nclass NullBuyingPowerOptionBullCallSpreadAlgorithm(QCAlgorithm):\n    def Initialize(self):\n\n        self.SetStartDate(2015, 12, 24)\n        self.SetEndDate(2015, 12, 24)\n        self.SetCash(200000)\n\n        self.SetSecurityInitializer(lambda security: security.SetMarginModel(SecurityMarginModel.Null))\n        self.Portfolio.SetPositions(SecurityPositionGroupModel.Null);\n\n        equity = self.AddEquity(\"GOOG\")\n        option = self.AddOption(equity.Symbol)\n        self.optionSymbol = option.Symbol\n\n        option.SetFilter(-2, 2, 0, 180)\n        \n    def OnData(self, slice):\n        if self.Portfolio.Invested or not self.IsMarketOpen(self.optionSymbol):\n            return\n       \n        chain = slice.OptionChains.get(self.optionSymbol)\n        if chain:\n            call_contracts = [x for x in chain if x.Right == OptionRight.Call]\n\n            expiry = min(x.Expiry for x in call_contracts)\n\n            call_contracts = sorted([x for x in call_contracts if x.Expiry == expiry],\n                key = lambda x: x.Strike)\n\n            long_call = call_contracts[0]\n            short_call = [x for x in call_contracts if x.Strike > long_call.Strike][0]\n\n            quantity = 1000\n\n            tickets = [\n                self.MarketOrder(short_call.Symbol, -quantity),\n                self.MarketOrder(long_call.Symbol, quantity)\n            ]\n                \n            for ticket in tickets:\n                if ticket.Status != OrderStatus.Filled:\n                    raise Exception(f\"There should be no restriction on buying {ticket.Quantity} of {ticket.Symbol} with BuyingPowerModel.Null\")\n\n\n    def OnEndOfAlgorithm(self) -> None:\n        if self.Portfolio.TotalMarginUsed != 0:\n            raise Exception(\"The TotalMarginUsed should be zero to avoid margin calls.\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you help me write a regression algorithm for an equity covered American style option using an option price model that supports American style options?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom OptionPriceModelForOptionStylesBaseRegressionAlgorithm import OptionPriceModelForOptionStylesBaseRegressionAlgorithm\n\n### <summary>\n### Regression algorithm exercising an equity covered American style option, using an option price model\n### that supports American style options and asserting that the option price model is used.\n### </summary>\nclass OptionPriceModelForUnsupportedAmericanOptionRegressionAlgorithm(OptionPriceModelForOptionStylesBaseRegressionAlgorithm):\n    def Initialize(self):\n        self.SetStartDate(2014, 6, 9)\n        self.SetEndDate(2014, 6, 9)\n\n        option = self.AddOption(\"AAPL\", Resolution.Minute)\n        # BlackSholes model does not support American style options\n        option.PriceModel = OptionPriceModels.BlackScholes()\n\n        self.SetWarmup(2, Resolution.Daily)\n\n        self.Init(option, optionStyleIsSupported=False)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a query that would result in the code you mentioned?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": "﻿# QUANTCONNECT.COM - Democratizing Finance, Empowering Individuals.\n# Lean Algorithmic Trading Engine v2.0. Copyright 2014 QuantConnect Corporation.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License\n\nfrom AlgorithmImports import *\n\n### <summary>\n### This regression algorithm tests using FutureOptions daily resolution\n### </summary>\nclass FutureOptionHourlyRegressionAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n        self.SetStartDate(2012, 1, 3)\n        self.SetEndDate(2012, 1, 4)\n        resolution = Resolution.Hour\n\n        # Add our underlying future contract\n        self.dc = self.AddFutureContract(\n            Symbol.CreateFuture(\n                Futures.Dairy.ClassIIIMilk,\n                Market.CME,\n                datetime(2012, 4, 1)\n            ),\n            resolution).Symbol\n\n        # Attempt to fetch a specific ITM future option contract\n        dcOptions = [\n            self.AddFutureOptionContract(x, resolution).Symbol for x in (self.OptionChainProvider.GetOptionContractList(self.dc, self.Time)) if x.ID.StrikePrice == 17 and x.ID.OptionRight == OptionRight.Call\n        ]\n        self.dcOption = dcOptions[0]\n\n        # Validate it is the expected contract\n        expectedContract = Symbol.CreateOption(self.dc, Market.CME, OptionStyle.American, OptionRight.Call, 17, datetime(2012, 4, 1))\n        if self.dcOption != expectedContract:\n            raise AssertionError(f\"Contract {self.dcOption} was not the expected contract {expectedContract}\")\n\n        # Schedule a purchase of this contract at noon\n        self.Schedule.On(self.DateRules.Today, self.TimeRules.Noon, self.ScheduleCallbackBuy)\n\n        # Schedule liquidation at 2pm when the market is open\n        self.Schedule.On(self.DateRules.Today, self.TimeRules.At(14,0,0), self.ScheduleCallbackLiquidate)\n\n    def ScheduleCallbackBuy(self):\n        self.ticket = self.MarketOrder(self.dcOption, 1)\n\n    def OnData(self, slice):\n        # Assert we are only getting data at 7PM (12AM UTC)\n        if slice.Time.minute != 0:\n            raise AssertionError(f\"Expected data only on hourly intervals; instead was {slice.Time}\")\n\n    def ScheduleCallbackLiquidate(self):\n        self.Liquidate()\n\n    def OnEndOfAlgorithm(self):\n        if self.Portfolio.Invested:\n            raise AssertionError(f\"Expected no holdings at end of algorithm, but are invested in: {', '.join([str(i.ID) for i in self.Portfolio.Keys])}\")\n\n        if self.ticket.Status != OrderStatus.Filled:\n            raise AssertionError(\"Future option order failed to fill correctly\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with a code example demonstrating importing and trading on custom data using the Lean Algorithmic Trading Engine?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Regression test to demonstrate importing and trading on custom data.\n### </summary>\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"importing data\" />\n### <meta name=\"tag\" content=\"custom data\" />\n### <meta name=\"tag\" content=\"crypto\" />\n### <meta name=\"tag\" content=\"regression test\" />\nclass CustomDataRegressionAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n\n        self.SetStartDate(2011,9,14)   # Set Start Date\n        self.SetEndDate(2015,12,1)     # Set End Date\n        self.SetCash(100000)           # Set Strategy Cash\n\n        resolution = Resolution.Second if self.LiveMode else Resolution.Daily\n        self.AddData(Bitcoin, \"BTC\", resolution)\n\n        seeder = FuncSecuritySeeder(self.GetLastKnownPrices)\n        self.SetSecurityInitializer(lambda x: seeder.SeedSecurity(x))\n        self._warmedUpChecked = False\n\n    def OnData(self, data):\n        if not self.Portfolio.Invested:\n            if data['BTC'].Close != 0 :\n                self.Order('BTC', self.Portfolio.MarginRemaining/abs(data['BTC'].Close + 1))\n\n    def OnSecuritiesChanged(self, changes):\n        changes.FilterCustomSecurities = False\n        for addedSecurity in changes.AddedSecurities:\n            if addedSecurity.Symbol.Value == \"BTC\":\n                self._warmedUpChecked = True\n            if not addedSecurity.HasData:\n                raise ValueError(f\"Security {addedSecurity.Symbol} was not warmed up!\")\n\n    def OnEndOfAlgorithm(self):\n        if not self._warmedUpChecked:\n            raise ValueError(\"Security was not warmed up!\")\n\nclass Bitcoin(PythonData):\n    '''Custom Data Type: Bitcoin data from Quandl - http://www.quandl.com/help/api-for-bitcoin-data'''\n\n    def GetSource(self, config, date, isLiveMode):\n        if isLiveMode:\n            return SubscriptionDataSource(\"https://www.bitstamp.net/api/ticker/\", SubscriptionTransportMedium.Rest)\n\n        #return \"http://my-ftp-server.com/futures-data-\" + date.ToString(\"Ymd\") + \".zip\"\n        # OR simply return a fixed small data file. Large files will slow down your backtest\n        return SubscriptionDataSource(\"https://www.quantconnect.com/api/v2/proxy/quandl/api/v3/datasets/BCHARTS/BITSTAMPUSD.csv?order=asc&api_key=WyAazVXnq7ATy_fefTqm\", SubscriptionTransportMedium.RemoteFile)\n\n\n    def Reader(self, config, line, date, isLiveMode):\n        coin = Bitcoin()\n        coin.Symbol = config.Symbol\n\n        if isLiveMode:\n            # Example Line Format:\n            # {\"high\": \"441.00\", \"last\": \"421.86\", \"timestamp\": \"1411606877\", \"bid\": \"421.96\", \"vwap\": \"428.58\", \"volume\": \"14120.40683975\", \"low\": \"418.83\", \"ask\": \"421.99\"}\n            try:\n                liveBTC = json.loads(line)\n\n                # If value is zero, return None\n                value = liveBTC[\"last\"]\n                if value == 0: return None\n\n                coin.Time = datetime.now()\n                coin.Value = value\n                coin[\"Open\"] = float(liveBTC[\"open\"])\n                coin[\"High\"] = float(liveBTC[\"high\"])\n                coin[\"Low\"] = float(liveBTC[\"low\"])\n                coin[\"Close\"] = float(liveBTC[\"last\"])\n                coin[\"Ask\"] = float(liveBTC[\"ask\"])\n                coin[\"Bid\"] = float(liveBTC[\"bid\"])\n                coin[\"VolumeBTC\"] = float(liveBTC[\"volume\"])\n                coin[\"WeightedPrice\"] = float(liveBTC[\"vwap\"])\n                return coin\n            except ValueError:\n                # Do nothing, possible error in json decoding\n                return None\n\n        # Example Line Format:\n        # Date      Open   High    Low     Close   Volume (BTC)    Volume (Currency)   Weighted Price\n        # 2011-09-13 5.8    6.0     5.65    5.97    58.37138238,    346.0973893944      5.929230648356\n        if not (line.strip() and line[0].isdigit()): return None\n\n        try:\n            data = line.split(',')\n            coin.Time = datetime.strptime(data[0], \"%Y-%m-%d\")\n            coin.EndTime = coin.Time + timedelta(days=1)\n            coin.Value = float(data[4])\n            coin[\"Open\"] = float(data[1])\n            coin[\"High\"] = float(data[2])\n            coin[\"Low\"] = float(data[3])\n            coin[\"Close\"] = float(data[4])\n            coin[\"VolumeBTC\"] = float(data[5])\n            coin[\"VolumeUSD\"] = float(data[6])\n            coin[\"WeightedPrice\"] = float(data[7])\n            return coin\n\n        except ValueError:\n            # Do nothing, possible error in json decoding\n            return None"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Please provide a query that would result in the code above.\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Example and regression algorithm asserting the behavior of registering and unregistering an indicator from the engine\n### </summary>\nclass UnregisterIndicatorRegressionAlgorithm(QCAlgorithm):\n    def Initialize(self):\n        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n        self.SetStartDate(2013,10, 7)\n        self.SetEndDate(2013,10,11)\n\n        spy = self.AddEquity(\"SPY\")\n        ibm = self.AddEquity(\"IBM\")\n\n        self._symbols = [ spy.Symbol, ibm.Symbol ]\n        self._trin = self.TRIN(self._symbols, Resolution.Minute)\n        self._trin2 = None\n\n    def OnData(self, data):\n        '''OnData event is the primary entry point for your algorithm. Each new data point will be pumped in here.\n\n        Arguments:\n            data: Slice object keyed by symbol containing the stock data\n        '''\n        if self._trin.IsReady:\n            self._trin.Reset()\n            self.UnregisterIndicator(self._trin)\n\n            # let's create a new one with a differente resolution\n            self._trin2 = self.TRIN(self._symbols, Resolution.Hour)\n\n        if not self._trin2 is None and self._trin2.IsReady:\n            if self._trin.IsReady:\n                raise ValueError(\"Indicator should of stop getting updates!\")\n\n            if not self.Portfolio.Invested:\n                self.SetHoldings(self._symbols[0], 0.5)\n                self.SetHoldings(self._symbols[1], 0.5)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I create a trading algorithm that calculates the DEMA, EMA, and WMA indicators for the SPY stock using a rolling window?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nimport talib\n\nclass CalibratedResistanceAtmosphericScrubbers(QCAlgorithm):\n\n    def Initialize(self):\n        self.SetStartDate(2020, 1, 2)\n        self.SetEndDate(2020, 1, 6) \n        self.SetCash(100000) \n        self.AddEquity(\"SPY\", Resolution.Hour)\n        \n        self.rolling_window = pd.DataFrame()\n        self.dema_period = 3\n        self.sma_period = 3\n        self.wma_period = 3\n        self.window_size = self.dema_period * 2\n        self.SetWarmUp(self.window_size)\n        \n    def OnData(self, data):\n        if \"SPY\" not in data.Bars:\n            return\n        \n        close = data[\"SPY\"].Close\n        \n        if self.IsWarmingUp:\n            # Add latest close to rolling window\n            row = pd.DataFrame({\"close\": [close]}, index=[data.Time])\n            self.rolling_window = self.rolling_window.append(row).iloc[-self.window_size:]\n            \n            # If we have enough closing data to start calculating indicators...\n            if self.rolling_window.shape[0] == self.window_size:\n                closes = self.rolling_window['close'].values\n                \n                # Add indicator columns to DataFrame\n                self.rolling_window['DEMA'] = talib.DEMA(closes, self.dema_period)\n                self.rolling_window['EMA'] = talib.EMA(closes, self.sma_period)\n                self.rolling_window['WMA'] = talib.WMA(closes, self.wma_period)\n            return\n        \n        closes = np.append(self.rolling_window['close'].values, close)[-self.window_size:]\n        \n        # Update talib indicators time series with the latest close\n        row = pd.DataFrame({\"close\": close,\n                            \"DEMA\" : talib.DEMA(closes, self.dema_period)[-1],\n                            \"EMA\"  : talib.EMA(closes, self.sma_period)[-1],\n                            \"WMA\"  : talib.WMA(closes, self.wma_period)[-1]},\n                            index=[data.Time])\n        \n        self.rolling_window = self.rolling_window.append(row).iloc[-self.window_size:]\n\n        \n    def OnEndOfAlgorithm(self):\n        self.Log(f\"\\nRolling Window:\\n{self.rolling_window.to_string()}\\n\")\n        self.Log(f\"\\nLatest Values:\\n{self.rolling_window.iloc[-1].to_string()}\\n\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Please provide a possible query by a Quant Trader to a Coding assistant that would result in the following code.\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\nfrom Alphas.ConstantAlphaModel import ConstantAlphaModel\nfrom Selection.FutureUniverseSelectionModel import FutureUniverseSelectionModel\n\n### <summary>\n### Basic template futures framework algorithm uses framework components\n### to define an algorithm that trades futures.\n### </summary>\nclass BasicTemplateFuturesFrameworkAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n\n        self.UniverseSettings.Resolution = Resolution.Minute\n        self.UniverseSettings.ExtendedMarketHours = self.GetExtendedMarketHours()\n\n        self.SetStartDate(2013, 10, 7)\n        self.SetEndDate(2013, 10, 11)\n        self.SetCash(100000)\n\n        # set framework models\n        self.SetUniverseSelection(FrontMonthFutureUniverseSelectionModel(self.SelectFutureChainSymbols))\n        self.SetAlpha(ConstantFutureContractAlphaModel(InsightType.Price, InsightDirection.Up, timedelta(1)))\n        self.SetPortfolioConstruction(SingleSharePortfolioConstructionModel())\n        self.SetExecution(ImmediateExecutionModel())\n        self.SetRiskManagement(NullRiskManagementModel())\n\n\n    def SelectFutureChainSymbols(self, utcTime):\n        newYorkTime = Extensions.ConvertFromUtc(utcTime, TimeZones.NewYork)\n        if newYorkTime.date() < date(2013, 10, 9):\n            return [ Symbol.Create(Futures.Indices.SP500EMini, SecurityType.Future, Market.CME) ]\n        else:\n            return [ Symbol.Create(Futures.Metals.Gold, SecurityType.Future, Market.COMEX) ]\n\n    def GetExtendedMarketHours(self):\n        return False\n\nclass FrontMonthFutureUniverseSelectionModel(FutureUniverseSelectionModel):\n    '''Creates futures chain universes that select the front month contract and runs a user\n    defined futureChainSymbolSelector every day to enable choosing different futures chains'''\n    def __init__(self, select_future_chain_symbols):\n        super().__init__(timedelta(1), select_future_chain_symbols)\n\n    def Filter(self, filter):\n        '''Defines the futures chain universe filter'''\n        return (filter.FrontMonth()\n                      .OnlyApplyFilterAtMarketOpen())\n\nclass ConstantFutureContractAlphaModel(ConstantAlphaModel):\n    '''Implementation of a constant alpha model that only emits insights for future symbols'''\n    def __init__(self, type, direction, period):\n        super().__init__(type, direction, period)\n\n    def ShouldEmitInsight(self, utcTime, symbol):\n        # only emit alpha for future symbols and not underlying equity symbols\n        if symbol.SecurityType != SecurityType.Future:\n            return False\n\n        return super().ShouldEmitInsight(utcTime, symbol)\n\nclass SingleSharePortfolioConstructionModel(PortfolioConstructionModel):\n    '''Portfolio construction model that sets target quantities to 1 for up insights and -1 for down insights'''\n    def CreateTargets(self, algorithm, insights):\n        targets = []\n        for insight in insights:\n            targets.append(PortfolioTarget(insight.Symbol, insight.Direction))\n        return targets"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I create an algorithm that uses a Regression Channel indicator to place buy and sell orders?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Regression Channel algorithm simply initializes the date range and cash\n### </summary>\n### <meta name=\"tag\" content=\"indicators\" />\n### <meta name=\"tag\" content=\"indicator classes\" />\n### <meta name=\"tag\" content=\"placing orders\" />\n### <meta name=\"tag\" content=\"plotting indicators\" />\nclass RegressionChannelAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n\n        self.SetCash(100000)\n        self.SetStartDate(2009,1,1)\n        self.SetEndDate(2015,1,1)\n\n        equity = self.AddEquity(\"SPY\", Resolution.Minute)\n        self._spy = equity.Symbol\n        self._holdings = equity.Holdings\n        self._rc = self.RC(self._spy, 30, 2, Resolution.Daily)\n\n        stockPlot = Chart(\"Trade Plot\")\n        stockPlot.AddSeries(Series(\"Buy\", SeriesType.Scatter, 0))\n        stockPlot.AddSeries(Series(\"Sell\", SeriesType.Scatter, 0))\n        stockPlot.AddSeries(Series(\"UpperChannel\", SeriesType.Line, 0))\n        stockPlot.AddSeries(Series(\"LowerChannel\", SeriesType.Line, 0))\n        stockPlot.AddSeries(Series(\"Regression\", SeriesType.Line, 0))\n        self.AddChart(stockPlot)\n\n    def OnData(self, data):\n        if (not self._rc.IsReady) or (not data.ContainsKey(self._spy)): return\n        if data[self._spy] is None: return\n        value = data[self._spy].Value\n        if self._holdings.Quantity <= 0 and value < self._rc.LowerChannel.Current.Value:\n            self.SetHoldings(self._spy, 1)\n            self.Plot(\"Trade Plot\", \"Buy\", value)\n        if self._holdings.Quantity >= 0 and value > self._rc.UpperChannel.Current.Value:\n            self.SetHoldings(self._spy, -1)\n            self.Plot(\"Trade Plot\", \"Sell\", value)\n\n    def OnEndOfDay(self, symbol):\n        self.Plot(\"Trade Plot\", \"UpperChannel\", self._rc.UpperChannel.Current.Value)\n        self.Plot(\"Trade Plot\", \"LowerChannel\", self._rc.LowerChannel.Current.Value)\n        self.Plot(\"Trade Plot\", \"Regression\", self._rc.LinearRegression.Current.Value)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I add options for a given underlying equity security and prefilter the contracts based on strikes and expirations in Python?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### This example demonstrates how to add options for a given underlying equity security.\n### It also shows how you can prefilter contracts easily based on strikes and expirations.\n### It also shows how you can inspect the option chain to pick a specific option contract to trade.\n### </summary>\n### <meta name=\"tag\" content=\"using data\" />\n### <meta name=\"tag\" content=\"options\" />\n### <meta name=\"tag\" content=\"filter selection\" />\nclass BasicTemplateOptionsFilterUniverseAlgorithm(QCAlgorithm):\n    UnderlyingTicker = \"GOOG\"\n\n    def Initialize(self):\n        self.SetStartDate(2015, 12, 24)\n        self.SetEndDate(2015, 12, 28)\n        self.SetCash(100000)\n\n        equity = self.AddEquity(self.UnderlyingTicker)\n        option = self.AddOption(self.UnderlyingTicker)\n        self.OptionSymbol = option.Symbol\n\n        # Set our custom universe filter\n        option.SetFilter(self.FilterFunction)\n\n        # use the underlying equity as the benchmark\n        self.SetBenchmark(equity.Symbol)\n\n    def FilterFunction(self, universe):\n        #Expires today, is a call, and is within 10 dollars of the current price\n        universe = universe.WeeklysOnly().Expiration(0, 1)\n        return [symbol for symbol in universe \n                if symbol.ID.OptionRight != OptionRight.Put \n                and -10 < universe.Underlying.Price - symbol.ID.StrikePrice < 10]\n\n    def OnData(self,slice):\n        if self.Portfolio.Invested: return\n\n        for kvp in slice.OptionChains:\n            \n            if kvp.Key != self.OptionSymbol: continue\n\n            # Get the first call strike under market price expiring today\n            chain = kvp.Value\n            contracts = [option for option in sorted(chain, key = lambda x:x.Strike, reverse = True)\n                         if option.Expiry.date() == self.Time.date()\n                         and option.Strike < chain.Underlying.Price]\n            \n            if contracts:\n                self.MarketOrder(contracts[0].Symbol, 1)"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I use the OptionStrategies helper class to send batch orders for common strategies in the QuantConnect algorithmic trading engine?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom QuantConnect.Securities.Positions import IPositionGroup\n\n### <summary>\n### This base algorithm demonstrates how to use OptionStrategies helper class to batch send orders for common strategies.\n### </summary>\nclass OptionStrategyFactoryMethodsBaseAlgorithm(QCAlgorithm):\n\n    def Initialize(self):\n        self.SetStartDate(2015, 12, 24)\n        self.SetEndDate(2015, 12, 24)\n        self.SetCash(1000000)\n\n        option = self.AddOption(\"GOOG\")\n        self._option_symbol = option.Symbol\n\n        option.SetFilter(-2, +2, 0, 180)\n\n        self.SetBenchmark(\"GOOG\")\n\n    def OnData(self, slice):\n        if not self.Portfolio.Invested:\n            chain = slice.OptionChains.get(self._option_symbol)\n            if chain is not None:\n                self.TradeStrategy(chain, self._option_symbol)\n        else:\n            # Verify that the strategy was traded\n            positionGroup = list(self.Portfolio.Positions.Groups)[0]\n\n            buyingPowerModel = positionGroup.BuyingPowerModel\n            if not isinstance(buyingPowerModel, OptionStrategyPositionGroupBuyingPowerModel):\n                raise Exception(\"Expected position group buying power model type: OptionStrategyPositionGroupBuyingPowerModel. \"\n                                f\"Actual: {type(positionGroup.BuyingPowerModel).__name__}\")\n\n            self.AssertStrategyPositionGroup(positionGroup, self._option_symbol)\n\n            # Now we should be able to close the position\n            self.LiquidateStrategy()\n\n            # We can quit now, no more testing required\n            self.Quit()\n\n    def OnEndOfAlgorithm(self):\n        if self.Portfolio.Invested:\n            raise Exception(\"Expected no holdings at end of algorithm\")\n\n        orders_count = len(list(self.Transactions.GetOrders(lambda order: order.Status == OrderStatus.Filled)))\n        if orders_count != self.ExpectedOrdersCount():\n            raise Exception(f\"Expected {self.ExpectedOrdersCount()} orders to have been submitted and filled, \"\n                            f\"half for buying the strategy and the other half for the liquidation. Actual {orders_count}\")\n\n    def ExpectedOrdersCount(self) -> int:\n        raise NotImplementedError(\"ExpectedOrdersCount method is not implemented\")\n\n    def TradeStrategy(self, chain: OptionChain, option_symbol: Symbol) -> None:\n        raise NotImplementedError(\"TradeStrategy method is not implemented\")\n\n    def AssertStrategyPositionGroup(self, positionGroup: IPositionGroup, option_symbol: Symbol) -> None:\n        raise NotImplementedError(\"AssertStrategyPositionGroup method is not implemented\")\n\n    def LiquidateStrategy(self) -> None:\n        raise NotImplementedError(\"LiquidateStrategy method is not implemented\")"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I use indicators history window in my algorithm?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Demonstration algorithm of indicators history window usage\n### </summary>\nclass IndicatorHistoryAlgorithm(QCAlgorithm):\n    '''Demonstration algorithm of indicators history window usage.'''\n\n    def Initialize(self):\n        '''Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n        self.SetStartDate(2013, 1, 1)\n        self.SetEndDate(2014, 12, 31)\n        self.SetCash(25000)\n\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n\n        self.bollingerBands = self.BB(self.symbol, 20, 2.0, resolution=Resolution.Daily)\n        # Let's keep BB values for a 20 day period\n        self.bollingerBands.Window.Size = 20\n        # Also keep the same period of data for the middle band\n        self.bollingerBands.MiddleBand.Window.Size = 20;\n\n    def OnData(self, slice: Slice):\n        # Let's wait for our indicator to fully initialize and have a full window of history data\n        if not self.bollingerBands.Window.IsReady: return\n\n        # We can access the current and oldest (in our period) values of the indicator\n        self.Log(f\"Current BB value: {self.bollingerBands[0].EndTime} - {self.bollingerBands[0].Value}\")\n        self.Log(f\"Oldest BB value: {self.bollingerBands[self.bollingerBands.Window.Count - 1].EndTime} - \"\n                 f\"{self.bollingerBands[self.bollingerBands.Window.Count - 1].Value}\")\n\n        # Let's log the BB values for the last 20 days, for demonstration purposes on how it can be enumerated\n        for dataPoint in self.bollingerBands:\n            self.Log(f\"BB @{dataPoint.EndTime}: {dataPoint.Value}\")\n\n        # We can also do the same for internal indicators:\n        middleBand = self.bollingerBands.MiddleBand\n        self.Log(f\"Current BB Middle Band value: {middleBand[0].EndTime} - {middleBand[0].Value}\")\n        self.Log(f\"Oldest BB Middle Band value: {middleBand[middleBand.Window.Count - 1].EndTime} - \"\n                 f\"{middleBand[middleBand.Window.Count - 1].Value}\")\n        for dataPoint in middleBand:\n            self.Log(f\"BB Middle Band @{dataPoint.EndTime}: {dataPoint.Value}\")\n\n        # We are done now!\n        self.Quit()"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: How can I create a custom algorithm in QuantConnect that uses a custom coarse/fine fundamental selection model, an equally weighted portfolio construction model, and a maximum sector exposure risk management model?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\nfrom Portfolio.EqualWeightingPortfolioConstructionModel import EqualWeightingPortfolioConstructionModel\nfrom Alphas.ConstantAlphaModel import ConstantAlphaModel\nfrom Execution.ImmediateExecutionModel import ImmediateExecutionModel\nfrom Risk.MaximumSectorExposureRiskManagementModel import MaximumSectorExposureRiskManagementModel\n\n### <summary>\n### This example algorithm defines its own custom coarse/fine fundamental selection model\n### with equally weighted portfolio and a maximum sector exposure.\n### </summary>\nclass SectorExposureRiskFrameworkAlgorithm(QCAlgorithm):\n    '''This example algorithm defines its own custom coarse/fine fundamental selection model\n### with equally weighted portfolio and a maximum sector exposure.'''\n\n    def Initialize(self):\n\n        # Set requested data resolution\n        self.UniverseSettings.Resolution = Resolution.Daily\n\n        self.SetStartDate(2014, 3, 25)\n        self.SetEndDate(2014, 4, 7)\n        self.SetCash(100000)\n\n        # set algorithm framework models\n        self.SetUniverseSelection(FineFundamentalUniverseSelectionModel(self.SelectCoarse, self.SelectFine))\n        self.SetAlpha(ConstantAlphaModel(InsightType.Price, InsightDirection.Up, timedelta(1)))\n        self.SetPortfolioConstruction(EqualWeightingPortfolioConstructionModel())\n        self.SetRiskManagement(MaximumSectorExposureRiskManagementModel())\n\n    def OnOrderEvent(self, orderEvent):\n        if orderEvent.Status == OrderStatus.Filled:\n            self.Debug(f\"Order event: {orderEvent}. Holding value: {self.Securities[orderEvent.Symbol].Holdings.AbsoluteHoldingsValue}\")\n\n    def SelectCoarse(self, coarse):\n        tickers = [\"AAPL\", \"AIG\", \"IBM\"] if self.Time.date() < date(2014, 4, 1) else [ \"GOOG\", \"BAC\", \"SPY\" ]\n        return [Symbol.Create(x, SecurityType.Equity, Market.USA) for x in tickers]\n\n    def SelectFine(self, fine):\n        return [f.Symbol for f in fine]"
    },
    {
        "instruction": "Read the context below and answer the questions.\n    Context:You are a helpful assistant for quant trading.\n    Question: Can you provide me with an example of a Quant Trading algorithm that uses a custom insight scoring function and the insight manager?\n\n    Requirements:\n    - Your answers should be in python code.\n    - Please add relevant instructions to the code in the form of comments\n    - Please reason step by step and put the final answer into \\boxed{}\n    - Your inference length should not be lower than 2048 tokens\n    - When you think the generation is over, you need to double check your reasoning logic to make sure the output is correct.",
        "input": "",
        "output": " from AlgorithmImports import *\n\n### <summary>\n### Regression algorithm showing how to define a custom insight scoring function and using the insight manager\n### </summary>\nclass InsightScoringRegressionAlgorithm(QCAlgorithm):\n    '''Regression algorithm showing how to define a custom insight evaluator'''\n\n    def Initialize(self):\n        ''' Initialise the data and resolution required, as well as the cash and start-end dates for your algorithm. All algorithms must initialized.'''\n        self.SetStartDate(2013,10,7)\n        self.SetEndDate(2013,10,11)\n        \n        symbols = [ Symbol.Create(\"SPY\", SecurityType.Equity, Market.USA) ]\n\n        self.SetUniverseSelection(ManualUniverseSelectionModel(symbols))\n        self.SetAlpha(ConstantAlphaModel(InsightType.Price, InsightDirection.Up, timedelta(minutes = 20), 0.025, None))\n        self.SetPortfolioConstruction(EqualWeightingPortfolioConstructionModel(Resolution.Daily))\n        self.SetExecution(ImmediateExecutionModel())\n        self.SetRiskManagement(MaximumDrawdownPercentPerSecurity(0.01))\n        \n        # we specify a custom insight evaluator\n        self.Insights.SetInsightScoreFunction(CustomInsightScoreFunction(self.Securities))\n\n    def OnEndOfAlgorithm(self):\n        allInsights = self.Insights.GetInsights(lambda insight: True)\n\n        if len(allInsights) != 100 or len(self.Insights.GetInsights()) != 100:\n            raise ValueError(f'Unexpected insight count found {allInsights.Count}')\n\n        if sum(1 for insight in allInsights if insight.Score.Magnitude == 0 or insight.Score.Direction == 0) < 5:\n            raise ValueError(f'Insights not scored!')\n\n        if sum(1 for insight in allInsights if insight.Score.IsFinalScore) < 99:\n            raise ValueError(f'Insights not finalized!')\n\nclass CustomInsightScoreFunction():\n\n    def __init__(self, securities):\n        self._securities = securities\n        self._openInsights = {}\n\n    def Score(self, insightManager, utcTime):\n        openInsights = insightManager.GetActiveInsights(utcTime)\n\n        for insight in openInsights:\n            self._openInsights[insight.Id] = insight\n\n        toRemove = []\n        for openInsight in self._openInsights.values():\n            security = self._securities[openInsight.Symbol]\n            openInsight.ReferenceValueFinal = security.Price\n\n            score = openInsight.ReferenceValueFinal - openInsight.ReferenceValue\n            openInsight.Score.SetScore(InsightScoreType.Direction, score, utcTime)\n            openInsight.Score.SetScore(InsightScoreType.Magnitude, score * 2, utcTime)\n            openInsight.EstimatedValue = score * 100\n\n            if openInsight.IsExpired(utcTime):\n                openInsight.Score.Finalize(utcTime)\n                toRemove.append(openInsight)\n\n        # clean up\n        for insightToRemove in toRemove:\n            self._openInsights.pop(insightToRemove.Id)"
    }
]